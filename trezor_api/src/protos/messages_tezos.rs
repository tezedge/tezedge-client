// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-tezos.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct TezosGetAddress {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosGetAddress {
    fn default() -> &'a TezosGetAddress {
        <TezosGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl TezosGetAddress {
    pub fn new() -> TezosGetAddress {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosGetAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosGetAddress {
        TezosGetAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &TezosGetAddress| { &m.address_n },
                |m: &mut TezosGetAddress| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_display",
                |m: &TezosGetAddress| { &m.show_display },
                |m: &mut TezosGetAddress| { &mut m.show_display },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosGetAddress>(
                "TezosGetAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosGetAddress {
        static instance: ::protobuf::rt::LazyV2<TezosGetAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosGetAddress::new)
    }
}

impl ::protobuf::Clear for TezosGetAddress {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosGetAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosAddress {
    // message fields
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosAddress {
    fn default() -> &'a TezosAddress {
        <TezosAddress as ::protobuf::Message>::default_instance()
    }
}

impl TezosAddress {
    pub fn new() -> TezosAddress {
        ::std::default::Default::default()
    }

    // optional string address = 1;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosAddress {
        TezosAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &TezosAddress| { &m.address },
                |m: &mut TezosAddress| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosAddress>(
                "TezosAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosAddress {
        static instance: ::protobuf::rt::LazyV2<TezosAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosAddress::new)
    }
}

impl ::protobuf::Clear for TezosAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosGetPublicKey {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosGetPublicKey {
    fn default() -> &'a TezosGetPublicKey {
        <TezosGetPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TezosGetPublicKey {
    pub fn new() -> TezosGetPublicKey {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosGetPublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosGetPublicKey {
        TezosGetPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &TezosGetPublicKey| { &m.address_n },
                |m: &mut TezosGetPublicKey| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_display",
                |m: &TezosGetPublicKey| { &m.show_display },
                |m: &mut TezosGetPublicKey| { &mut m.show_display },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosGetPublicKey>(
                "TezosGetPublicKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosGetPublicKey {
        static instance: ::protobuf::rt::LazyV2<TezosGetPublicKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosGetPublicKey::new)
    }
}

impl ::protobuf::Clear for TezosGetPublicKey {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosGetPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosGetPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosPublicKey {
    // message fields
    public_key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosPublicKey {
    fn default() -> &'a TezosPublicKey {
        <TezosPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TezosPublicKey {
    pub fn new() -> TezosPublicKey {
        ::std::default::Default::default()
    }

    // optional string public_key = 1;


    pub fn get_public_key(&self) -> &str {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::string::String) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::string::String {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::string::String {
        self.public_key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosPublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosPublicKey {
        TezosPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "public_key",
                |m: &TezosPublicKey| { &m.public_key },
                |m: &mut TezosPublicKey| { &mut m.public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosPublicKey>(
                "TezosPublicKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosPublicKey {
        static instance: ::protobuf::rt::LazyV2<TezosPublicKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosPublicKey::new)
    }
}

impl ::protobuf::Clear for TezosPublicKey {
    fn clear(&mut self) {
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    branch: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub reveal: ::protobuf::SingularPtrField<TezosSignTx_TezosRevealOp>,
    pub transaction: ::protobuf::SingularPtrField<TezosSignTx_TezosTransactionOp>,
    pub origination: ::protobuf::SingularPtrField<TezosSignTx_TezosOriginationOp>,
    pub delegation: ::protobuf::SingularPtrField<TezosSignTx_TezosDelegationOp>,
    pub proposal: ::protobuf::SingularPtrField<TezosSignTx_TezosProposalOp>,
    pub ballot: ::protobuf::SingularPtrField<TezosSignTx_TezosBallotOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx {
    fn default() -> &'a TezosSignTx {
        <TezosSignTx as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx {
    pub fn new() -> TezosSignTx {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bytes branch = 2;


    pub fn get_branch(&self) -> &[u8] {
        match self.branch.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_branch(&mut self) {
        self.branch.clear();
    }

    pub fn has_branch(&self) -> bool {
        self.branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch(&mut self, v: ::std::vec::Vec<u8>) {
        self.branch = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.branch.is_none() {
            self.branch.set_default();
        }
        self.branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch(&mut self) -> ::std::vec::Vec<u8> {
        self.branch.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp reveal = 3;


    pub fn get_reveal(&self) -> &TezosSignTx_TezosRevealOp {
        self.reveal.as_ref().unwrap_or_else(|| <TezosSignTx_TezosRevealOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reveal(&mut self) {
        self.reveal.clear();
    }

    pub fn has_reveal(&self) -> bool {
        self.reveal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal(&mut self, v: TezosSignTx_TezosRevealOp) {
        self.reveal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal(&mut self) -> &mut TezosSignTx_TezosRevealOp {
        if self.reveal.is_none() {
            self.reveal.set_default();
        }
        self.reveal.as_mut().unwrap()
    }

    // Take field
    pub fn take_reveal(&mut self) -> TezosSignTx_TezosRevealOp {
        self.reveal.take().unwrap_or_else(|| TezosSignTx_TezosRevealOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp transaction = 4;


    pub fn get_transaction(&self) -> &TezosSignTx_TezosTransactionOp {
        self.transaction.as_ref().unwrap_or_else(|| <TezosSignTx_TezosTransactionOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TezosSignTx_TezosTransactionOp) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TezosSignTx_TezosTransactionOp {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TezosSignTx_TezosTransactionOp {
        self.transaction.take().unwrap_or_else(|| TezosSignTx_TezosTransactionOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp origination = 5;


    pub fn get_origination(&self) -> &TezosSignTx_TezosOriginationOp {
        self.origination.as_ref().unwrap_or_else(|| <TezosSignTx_TezosOriginationOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_origination(&mut self) {
        self.origination.clear();
    }

    pub fn has_origination(&self) -> bool {
        self.origination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origination(&mut self, v: TezosSignTx_TezosOriginationOp) {
        self.origination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origination(&mut self) -> &mut TezosSignTx_TezosOriginationOp {
        if self.origination.is_none() {
            self.origination.set_default();
        }
        self.origination.as_mut().unwrap()
    }

    // Take field
    pub fn take_origination(&mut self) -> TezosSignTx_TezosOriginationOp {
        self.origination.take().unwrap_or_else(|| TezosSignTx_TezosOriginationOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp delegation = 6;


    pub fn get_delegation(&self) -> &TezosSignTx_TezosDelegationOp {
        self.delegation.as_ref().unwrap_or_else(|| <TezosSignTx_TezosDelegationOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delegation(&mut self) {
        self.delegation.clear();
    }

    pub fn has_delegation(&self) -> bool {
        self.delegation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegation(&mut self, v: TezosSignTx_TezosDelegationOp) {
        self.delegation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegation(&mut self) -> &mut TezosSignTx_TezosDelegationOp {
        if self.delegation.is_none() {
            self.delegation.set_default();
        }
        self.delegation.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegation(&mut self) -> TezosSignTx_TezosDelegationOp {
        self.delegation.take().unwrap_or_else(|| TezosSignTx_TezosDelegationOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosProposalOp proposal = 7;


    pub fn get_proposal(&self) -> &TezosSignTx_TezosProposalOp {
        self.proposal.as_ref().unwrap_or_else(|| <TezosSignTx_TezosProposalOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: TezosSignTx_TezosProposalOp) {
        self.proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut TezosSignTx_TezosProposalOp {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> TezosSignTx_TezosProposalOp {
        self.proposal.take().unwrap_or_else(|| TezosSignTx_TezosProposalOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp ballot = 8;


    pub fn get_ballot(&self) -> &TezosSignTx_TezosBallotOp {
        self.ballot.as_ref().unwrap_or_else(|| <TezosSignTx_TezosBallotOp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ballot(&mut self) {
        self.ballot.clear();
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: TezosSignTx_TezosBallotOp) {
        self.ballot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ballot(&mut self) -> &mut TezosSignTx_TezosBallotOp {
        if self.ballot.is_none() {
            self.ballot.set_default();
        }
        self.ballot.as_mut().unwrap()
    }

    // Take field
    pub fn take_ballot(&mut self) -> TezosSignTx_TezosBallotOp {
        self.ballot.take().unwrap_or_else(|| TezosSignTx_TezosBallotOp::new())
    }
}

impl ::protobuf::Message for TezosSignTx {
    fn is_initialized(&self) -> bool {
        for v in &self.reveal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.origination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delegation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proposal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ballot {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.branch)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reveal)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origination)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegation)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposal)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ballot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.branch.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.reveal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.origination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(ref v) = self.branch.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.reveal.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.origination.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delegation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ballot.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx {
        TezosSignTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &TezosSignTx| { &m.address_n },
                |m: &mut TezosSignTx| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "branch",
                |m: &TezosSignTx| { &m.branch },
                |m: &mut TezosSignTx| { &mut m.branch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosRevealOp>>(
                "reveal",
                |m: &TezosSignTx| { &m.reveal },
                |m: &mut TezosSignTx| { &mut m.reveal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosTransactionOp>>(
                "transaction",
                |m: &TezosSignTx| { &m.transaction },
                |m: &mut TezosSignTx| { &mut m.transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosOriginationOp>>(
                "origination",
                |m: &TezosSignTx| { &m.origination },
                |m: &mut TezosSignTx| { &mut m.origination },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosDelegationOp>>(
                "delegation",
                |m: &TezosSignTx| { &m.delegation },
                |m: &mut TezosSignTx| { &mut m.delegation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosProposalOp>>(
                "proposal",
                |m: &TezosSignTx| { &m.proposal },
                |m: &mut TezosSignTx| { &mut m.proposal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosBallotOp>>(
                "ballot",
                |m: &TezosSignTx| { &m.ballot },
                |m: &mut TezosSignTx| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx>(
                "TezosSignTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx::new)
    }
}

impl ::protobuf::Clear for TezosSignTx {
    fn clear(&mut self) {
        self.address_n.clear();
        self.branch.clear();
        self.reveal.clear();
        self.transaction.clear();
        self.origination.clear();
        self.delegation.clear();
        self.proposal.clear();
        self.ballot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosContractID {
    // message fields
    tag: ::std::option::Option<TezosSignTx_TezosContractID_TezosContractType>,
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosContractID {
    fn default() -> &'a TezosSignTx_TezosContractID {
        <TezosSignTx_TezosContractID as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosContractID {
    pub fn new() -> TezosSignTx_TezosContractID {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID.TezosContractType tag = 1;


    pub fn get_tag(&self) -> TezosSignTx_TezosContractID_TezosContractType {
        self.tag.unwrap_or(TezosSignTx_TezosContractID_TezosContractType::Implicit)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: TezosSignTx_TezosContractID_TezosContractType) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosContractID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tag {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosContractID {
        TezosSignTx_TezosContractID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TezosSignTx_TezosContractID_TezosContractType>>(
                "tag",
                |m: &TezosSignTx_TezosContractID| { &m.tag },
                |m: &mut TezosSignTx_TezosContractID| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &TezosSignTx_TezosContractID| { &m.hash },
                |m: &mut TezosSignTx_TezosContractID| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosContractID>(
                "TezosSignTx.TezosContractID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosContractID {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosContractID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosContractID::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosContractID {
    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosContractID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosContractID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TezosSignTx_TezosContractID_TezosContractType {
    Implicit = 0,
    Originated = 1,
}

impl ::protobuf::ProtobufEnum for TezosSignTx_TezosContractID_TezosContractType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TezosSignTx_TezosContractID_TezosContractType> {
        match value {
            0 => ::std::option::Option::Some(TezosSignTx_TezosContractID_TezosContractType::Implicit),
            1 => ::std::option::Option::Some(TezosSignTx_TezosContractID_TezosContractType::Originated),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TezosSignTx_TezosContractID_TezosContractType] = &[
            TezosSignTx_TezosContractID_TezosContractType::Implicit,
            TezosSignTx_TezosContractID_TezosContractType::Originated,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TezosSignTx_TezosContractID_TezosContractType>("TezosSignTx.TezosContractID.TezosContractType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TezosSignTx_TezosContractID_TezosContractType {
}

impl ::std::default::Default for TezosSignTx_TezosContractID_TezosContractType {
    fn default() -> Self {
        TezosSignTx_TezosContractID_TezosContractType::Implicit
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosContractID_TezosContractType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosRevealOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosRevealOp {
    fn default() -> &'a TezosSignTx_TezosRevealOp {
        <TezosSignTx_TezosRevealOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosRevealOp {
    pub fn new() -> TezosSignTx_TezosRevealOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 7;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes public_key = 6;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosRevealOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosRevealOp {
        TezosSignTx_TezosRevealOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosRevealOp| { &m.source },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &TezosSignTx_TezosRevealOp| { &m.fee },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "counter",
                |m: &TezosSignTx_TezosRevealOp| { &m.counter },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_limit",
                |m: &TezosSignTx_TezosRevealOp| { &m.gas_limit },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "storage_limit",
                |m: &TezosSignTx_TezosRevealOp| { &m.storage_limit },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "public_key",
                |m: &TezosSignTx_TezosRevealOp| { &m.public_key },
                |m: &mut TezosSignTx_TezosRevealOp| { &mut m.public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosRevealOp>(
                "TezosSignTx.TezosRevealOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosRevealOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosRevealOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosRevealOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosRevealOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosRevealOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosRevealOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosTransactionOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    amount: ::std::option::Option<u64>,
    pub destination: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    parameters: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub parameters_manager: ::protobuf::SingularPtrField<TezosSignTx_TezosTransactionOp_TezosParametersManager>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosTransactionOp {
    fn default() -> &'a TezosSignTx_TezosTransactionOp {
        <TezosSignTx_TezosTransactionOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosTransactionOp {
    pub fn new() -> TezosSignTx_TezosTransactionOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 9;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 7;


    pub fn get_destination(&self) -> &TezosSignTx_TezosContractID {
        self.destination.as_ref().unwrap_or_else(|| <TezosSignTx_TezosContractID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: TezosSignTx_TezosContractID) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> TezosSignTx_TezosContractID {
        self.destination.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional bytes parameters = 8;


    pub fn get_parameters(&self) -> &[u8] {
        match self.parameters.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::vec::Vec<u8>) {
        self.parameters = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parameters.is_none() {
            self.parameters.set_default();
        }
        self.parameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::vec::Vec<u8> {
        self.parameters.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager parameters_manager = 10;


    pub fn get_parameters_manager(&self) -> &TezosSignTx_TezosTransactionOp_TezosParametersManager {
        self.parameters_manager.as_ref().unwrap_or_else(|| <TezosSignTx_TezosTransactionOp_TezosParametersManager as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parameters_manager(&mut self) {
        self.parameters_manager.clear();
    }

    pub fn has_parameters_manager(&self) -> bool {
        self.parameters_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters_manager(&mut self, v: TezosSignTx_TezosTransactionOp_TezosParametersManager) {
        self.parameters_manager = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters_manager(&mut self) -> &mut TezosSignTx_TezosTransactionOp_TezosParametersManager {
        if self.parameters_manager.is_none() {
            self.parameters_manager.set_default();
        }
        self.parameters_manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameters_manager(&mut self) -> TezosSignTx_TezosTransactionOp_TezosParametersManager {
        self.parameters_manager.take().unwrap_or_else(|| TezosSignTx_TezosTransactionOp_TezosParametersManager::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosTransactionOp {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameters_manager {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parameters)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameters_manager)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parameters.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.parameters_manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parameters.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.parameters_manager.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosTransactionOp {
        TezosSignTx_TezosTransactionOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosTransactionOp| { &m.source },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &TezosSignTx_TezosTransactionOp| { &m.fee },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "counter",
                |m: &TezosSignTx_TezosTransactionOp| { &m.counter },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_limit",
                |m: &TezosSignTx_TezosTransactionOp| { &m.gas_limit },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "storage_limit",
                |m: &TezosSignTx_TezosTransactionOp| { &m.storage_limit },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount",
                |m: &TezosSignTx_TezosTransactionOp| { &m.amount },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                "destination",
                |m: &TezosSignTx_TezosTransactionOp| { &m.destination },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parameters",
                |m: &TezosSignTx_TezosTransactionOp| { &m.parameters },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager>>(
                "parameters_manager",
                |m: &TezosSignTx_TezosTransactionOp| { &m.parameters_manager },
                |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.parameters_manager },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosTransactionOp>(
                "TezosSignTx.TezosTransactionOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosTransactionOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosTransactionOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosTransactionOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosTransactionOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.destination.clear();
        self.parameters.clear();
        self.parameters_manager.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosTransactionOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosTransactionOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosTransactionOp_TezosParametersManager {
    // message fields
    set_delegate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cancel_delegate: ::std::option::Option<bool>,
    pub transfer: ::protobuf::SingularPtrField<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosTransactionOp_TezosParametersManager {
    fn default() -> &'a TezosSignTx_TezosTransactionOp_TezosParametersManager {
        <TezosSignTx_TezosTransactionOp_TezosParametersManager as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosTransactionOp_TezosParametersManager {
    pub fn new() -> TezosSignTx_TezosTransactionOp_TezosParametersManager {
        ::std::default::Default::default()
    }

    // optional bytes set_delegate = 1;


    pub fn get_set_delegate(&self) -> &[u8] {
        match self.set_delegate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_set_delegate(&mut self) {
        self.set_delegate.clear();
    }

    pub fn has_set_delegate(&self) -> bool {
        self.set_delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_delegate(&mut self, v: ::std::vec::Vec<u8>) {
        self.set_delegate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_delegate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.set_delegate.is_none() {
            self.set_delegate.set_default();
        }
        self.set_delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_set_delegate(&mut self) -> ::std::vec::Vec<u8> {
        self.set_delegate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool cancel_delegate = 2;


    pub fn get_cancel_delegate(&self) -> bool {
        self.cancel_delegate.unwrap_or(false)
    }
    pub fn clear_cancel_delegate(&mut self) {
        self.cancel_delegate = ::std::option::Option::None;
    }

    pub fn has_cancel_delegate(&self) -> bool {
        self.cancel_delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_delegate(&mut self, v: bool) {
        self.cancel_delegate = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer transfer = 3;


    pub fn get_transfer(&self) -> &TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        self.transfer.as_ref().unwrap_or_else(|| <TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transfer(&mut self) {
        self.transfer.clear();
    }

    pub fn has_transfer(&self) -> bool {
        self.transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer(&mut self, v: TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer) {
        self.transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer(&mut self) -> &mut TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        if self.transfer.is_none() {
            self.transfer.set_default();
        }
        self.transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_transfer(&mut self) -> TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        self.transfer.take().unwrap_or_else(|| TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosTransactionOp_TezosParametersManager {
    fn is_initialized(&self) -> bool {
        for v in &self.transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.set_delegate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cancel_delegate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transfer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.set_delegate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.cancel_delegate {
            my_size += 2;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.set_delegate.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.cancel_delegate {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosTransactionOp_TezosParametersManager {
        TezosSignTx_TezosTransactionOp_TezosParametersManager::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "set_delegate",
                |m: &TezosSignTx_TezosTransactionOp_TezosParametersManager| { &m.set_delegate },
                |m: &mut TezosSignTx_TezosTransactionOp_TezosParametersManager| { &mut m.set_delegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cancel_delegate",
                |m: &TezosSignTx_TezosTransactionOp_TezosParametersManager| { &m.cancel_delegate },
                |m: &mut TezosSignTx_TezosTransactionOp_TezosParametersManager| { &mut m.cancel_delegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>>(
                "transfer",
                |m: &TezosSignTx_TezosTransactionOp_TezosParametersManager| { &m.transfer },
                |m: &mut TezosSignTx_TezosTransactionOp_TezosParametersManager| { &mut m.transfer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosTransactionOp_TezosParametersManager>(
                "TezosSignTx.TezosTransactionOp.TezosParametersManager",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosTransactionOp_TezosParametersManager {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosTransactionOp_TezosParametersManager> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosTransactionOp_TezosParametersManager::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosTransactionOp_TezosParametersManager {
    fn clear(&mut self) {
        self.set_delegate.clear();
        self.cancel_delegate = ::std::option::Option::None;
        self.transfer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosTransactionOp_TezosParametersManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosTransactionOp_TezosParametersManager {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    // message fields
    pub destination: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    amount: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    fn default() -> &'a TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        <TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    pub fn new() -> TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 1;


    pub fn get_destination(&self) -> &TezosSignTx_TezosContractID {
        self.destination.as_ref().unwrap_or_else(|| <TezosSignTx_TezosContractID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: TezosSignTx_TezosContractID) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> TezosSignTx_TezosContractID {
        self.destination.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional uint64 amount = 2;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                "destination",
                |m: &TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer| { &m.destination },
                |m: &mut TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount",
                |m: &TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer| { &m.amount },
                |m: &mut TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer>(
                "TezosSignTx.TezosTransactionOp.TezosParametersManager.TezosManagerTransfer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    fn clear(&mut self) {
        self.destination.clear();
        self.amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosTransactionOp_TezosParametersManager_TezosManagerTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosOriginationOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    manager_pubkey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    balance: ::std::option::Option<u64>,
    spendable: ::std::option::Option<bool>,
    delegatable: ::std::option::Option<bool>,
    delegate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    script: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosOriginationOp {
    fn default() -> &'a TezosSignTx_TezosOriginationOp {
        <TezosSignTx_TezosOriginationOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosOriginationOp {
    pub fn new() -> TezosSignTx_TezosOriginationOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 12;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes manager_pubkey = 6;


    pub fn get_manager_pubkey(&self) -> &[u8] {
        match self.manager_pubkey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_manager_pubkey(&mut self) {
        self.manager_pubkey.clear();
    }

    pub fn has_manager_pubkey(&self) -> bool {
        self.manager_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manager_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.manager_pubkey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manager_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.manager_pubkey.is_none() {
            self.manager_pubkey.set_default();
        }
        self.manager_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_manager_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.manager_pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 balance = 7;


    pub fn get_balance(&self) -> u64 {
        self.balance.unwrap_or(0)
    }
    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u64) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional bool spendable = 8;


    pub fn get_spendable(&self) -> bool {
        self.spendable.unwrap_or(false)
    }
    pub fn clear_spendable(&mut self) {
        self.spendable = ::std::option::Option::None;
    }

    pub fn has_spendable(&self) -> bool {
        self.spendable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spendable(&mut self, v: bool) {
        self.spendable = ::std::option::Option::Some(v);
    }

    // optional bool delegatable = 9;


    pub fn get_delegatable(&self) -> bool {
        self.delegatable.unwrap_or(false)
    }
    pub fn clear_delegatable(&mut self) {
        self.delegatable = ::std::option::Option::None;
    }

    pub fn has_delegatable(&self) -> bool {
        self.delegatable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegatable(&mut self, v: bool) {
        self.delegatable = ::std::option::Option::Some(v);
    }

    // optional bytes delegate = 10;


    pub fn get_delegate(&self) -> &[u8] {
        match self.delegate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: ::std::vec::Vec<u8>) {
        self.delegate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> ::std::vec::Vec<u8> {
        self.delegate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes script = 11;


    pub fn get_script(&self) -> &[u8] {
        match self.script.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_script(&mut self) {
        self.script.clear();
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::vec::Vec<u8>) {
        self.script = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.script.is_none() {
            self.script.set_default();
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::vec::Vec<u8> {
        self.script.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosOriginationOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                12 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.manager_pubkey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.balance = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spendable = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delegatable = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.delegate)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.script)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.manager_pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spendable {
            my_size += 2;
        }
        if let Some(v) = self.delegatable {
            my_size += 2;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.script.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(12, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.manager_pubkey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.spendable {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.delegatable {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.script.as_ref() {
            os.write_bytes(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosOriginationOp {
        TezosSignTx_TezosOriginationOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosOriginationOp| { &m.source },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &TezosSignTx_TezosOriginationOp| { &m.fee },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "counter",
                |m: &TezosSignTx_TezosOriginationOp| { &m.counter },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_limit",
                |m: &TezosSignTx_TezosOriginationOp| { &m.gas_limit },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "storage_limit",
                |m: &TezosSignTx_TezosOriginationOp| { &m.storage_limit },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "manager_pubkey",
                |m: &TezosSignTx_TezosOriginationOp| { &m.manager_pubkey },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.manager_pubkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "balance",
                |m: &TezosSignTx_TezosOriginationOp| { &m.balance },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spendable",
                |m: &TezosSignTx_TezosOriginationOp| { &m.spendable },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.spendable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delegatable",
                |m: &TezosSignTx_TezosOriginationOp| { &m.delegatable },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.delegatable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "delegate",
                |m: &TezosSignTx_TezosOriginationOp| { &m.delegate },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.delegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "script",
                |m: &TezosSignTx_TezosOriginationOp| { &m.script },
                |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.script },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosOriginationOp>(
                "TezosSignTx.TezosOriginationOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosOriginationOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosOriginationOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosOriginationOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosOriginationOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.manager_pubkey.clear();
        self.balance = ::std::option::Option::None;
        self.spendable = ::std::option::Option::None;
        self.delegatable = ::std::option::Option::None;
        self.delegate.clear();
        self.script.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosOriginationOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosOriginationOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosDelegationOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    delegate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosDelegationOp {
    fn default() -> &'a TezosSignTx_TezosDelegationOp {
        <TezosSignTx_TezosDelegationOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosDelegationOp {
    pub fn new() -> TezosSignTx_TezosDelegationOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 7;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes delegate = 6;


    pub fn get_delegate(&self) -> &[u8] {
        match self.delegate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: ::std::vec::Vec<u8>) {
        self.delegate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> ::std::vec::Vec<u8> {
        self.delegate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosDelegationOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.delegate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.delegate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosDelegationOp {
        TezosSignTx_TezosDelegationOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosDelegationOp| { &m.source },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &TezosSignTx_TezosDelegationOp| { &m.fee },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "counter",
                |m: &TezosSignTx_TezosDelegationOp| { &m.counter },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_limit",
                |m: &TezosSignTx_TezosDelegationOp| { &m.gas_limit },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "storage_limit",
                |m: &TezosSignTx_TezosDelegationOp| { &m.storage_limit },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "delegate",
                |m: &TezosSignTx_TezosDelegationOp| { &m.delegate },
                |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.delegate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosDelegationOp>(
                "TezosSignTx.TezosDelegationOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosDelegationOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosDelegationOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosDelegationOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosDelegationOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.delegate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosDelegationOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosDelegationOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosProposalOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    period: ::std::option::Option<u64>,
    pub proposals: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosProposalOp {
    fn default() -> &'a TezosSignTx_TezosProposalOp {
        <TezosSignTx_TezosProposalOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosProposalOp {
    pub fn new() -> TezosSignTx_TezosProposalOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 1;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 period = 2;


    pub fn get_period(&self) -> u64 {
        self.period.unwrap_or(0)
    }
    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: u64) {
        self.period = ::std::option::Option::Some(v);
    }

    // repeated bytes proposals = 4;


    pub fn get_proposals(&self) -> &[::std::vec::Vec<u8>] {
        &self.proposals
    }
    pub fn clear_proposals(&mut self) {
        self.proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposals(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proposals(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.proposals
    }

    // Take field
    pub fn take_proposals(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.proposals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosProposalOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.period = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.proposals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.proposals {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.period {
            os.write_uint64(2, v)?;
        }
        for v in &self.proposals {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosProposalOp {
        TezosSignTx_TezosProposalOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosProposalOp| { &m.source },
                |m: &mut TezosSignTx_TezosProposalOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "period",
                |m: &TezosSignTx_TezosProposalOp| { &m.period },
                |m: &mut TezosSignTx_TezosProposalOp| { &mut m.period },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proposals",
                |m: &TezosSignTx_TezosProposalOp| { &m.proposals },
                |m: &mut TezosSignTx_TezosProposalOp| { &mut m.proposals },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosProposalOp>(
                "TezosSignTx.TezosProposalOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosProposalOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosProposalOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosProposalOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosProposalOp {
    fn clear(&mut self) {
        self.source.clear();
        self.period = ::std::option::Option::None;
        self.proposals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosProposalOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosProposalOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosBallotOp {
    // message fields
    source: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    period: ::std::option::Option<u64>,
    proposal: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ballot: ::std::option::Option<TezosSignTx_TezosBallotOp_TezosBallotType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosBallotOp {
    fn default() -> &'a TezosSignTx_TezosBallotOp {
        <TezosSignTx_TezosBallotOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosBallotOp {
    pub fn new() -> TezosSignTx_TezosBallotOp {
        ::std::default::Default::default()
    }

    // optional bytes source = 1;


    pub fn get_source(&self) -> &[u8] {
        match self.source.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::vec::Vec<u8>) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::vec::Vec<u8> {
        self.source.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 period = 2;


    pub fn get_period(&self) -> u64 {
        self.period.unwrap_or(0)
    }
    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: u64) {
        self.period = ::std::option::Option::Some(v);
    }

    // optional bytes proposal = 3;


    pub fn get_proposal(&self) -> &[u8] {
        match self.proposal.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_proposal(&mut self) {
        self.proposal.clear();
    }

    pub fn has_proposal(&self) -> bool {
        self.proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.proposal.is_none() {
            self.proposal.set_default();
        }
        self.proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposal(&mut self) -> ::std::vec::Vec<u8> {
        self.proposal.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosBallotOp.TezosBallotType ballot = 4;


    pub fn get_ballot(&self) -> TezosSignTx_TezosBallotOp_TezosBallotType {
        self.ballot.unwrap_or(TezosSignTx_TezosBallotOp_TezosBallotType::Yay)
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = ::std::option::Option::None;
    }

    pub fn has_ballot(&self) -> bool {
        self.ballot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: TezosSignTx_TezosBallotOp_TezosBallotType) {
        self.ballot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosSignTx_TezosBallotOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.period = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.proposal)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ballot, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.proposal.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.ballot {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.period {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.proposal.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.ballot {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosBallotOp {
        TezosSignTx_TezosBallotOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "source",
                |m: &TezosSignTx_TezosBallotOp| { &m.source },
                |m: &mut TezosSignTx_TezosBallotOp| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "period",
                |m: &TezosSignTx_TezosBallotOp| { &m.period },
                |m: &mut TezosSignTx_TezosBallotOp| { &mut m.period },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proposal",
                |m: &TezosSignTx_TezosBallotOp| { &m.proposal },
                |m: &mut TezosSignTx_TezosBallotOp| { &mut m.proposal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TezosSignTx_TezosBallotOp_TezosBallotType>>(
                "ballot",
                |m: &TezosSignTx_TezosBallotOp| { &m.ballot },
                |m: &mut TezosSignTx_TezosBallotOp| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignTx_TezosBallotOp>(
                "TezosSignTx.TezosBallotOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignTx_TezosBallotOp {
        static instance: ::protobuf::rt::LazyV2<TezosSignTx_TezosBallotOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignTx_TezosBallotOp::new)
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosBallotOp {
    fn clear(&mut self) {
        self.source.clear();
        self.period = ::std::option::Option::None;
        self.proposal.clear();
        self.ballot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosBallotOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosBallotOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TezosSignTx_TezosBallotOp_TezosBallotType {
    Yay = 0,
    Nay = 1,
    Pass = 2,
}

impl ::protobuf::ProtobufEnum for TezosSignTx_TezosBallotOp_TezosBallotType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TezosSignTx_TezosBallotOp_TezosBallotType> {
        match value {
            0 => ::std::option::Option::Some(TezosSignTx_TezosBallotOp_TezosBallotType::Yay),
            1 => ::std::option::Option::Some(TezosSignTx_TezosBallotOp_TezosBallotType::Nay),
            2 => ::std::option::Option::Some(TezosSignTx_TezosBallotOp_TezosBallotType::Pass),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TezosSignTx_TezosBallotOp_TezosBallotType] = &[
            TezosSignTx_TezosBallotOp_TezosBallotType::Yay,
            TezosSignTx_TezosBallotOp_TezosBallotType::Nay,
            TezosSignTx_TezosBallotOp_TezosBallotType::Pass,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TezosSignTx_TezosBallotOp_TezosBallotType>("TezosSignTx.TezosBallotOp.TezosBallotType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TezosSignTx_TezosBallotOp_TezosBallotType {
}

impl ::std::default::Default for TezosSignTx_TezosBallotOp_TezosBallotType {
    fn default() -> Self {
        TezosSignTx_TezosBallotOp_TezosBallotType::Yay
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosBallotOp_TezosBallotType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignedTx {
    // message fields
    signature: ::protobuf::SingularField<::std::string::String>,
    sig_op_contents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    operation_hash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignedTx {
    fn default() -> &'a TezosSignedTx {
        <TezosSignedTx as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignedTx {
    pub fn new() -> TezosSignedTx {
        ::std::default::Default::default()
    }

    // optional string signature = 1;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        self.signature.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sig_op_contents = 2;


    pub fn get_sig_op_contents(&self) -> &[u8] {
        match self.sig_op_contents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sig_op_contents(&mut self) {
        self.sig_op_contents.clear();
    }

    pub fn has_sig_op_contents(&self) -> bool {
        self.sig_op_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig_op_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_op_contents = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_op_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sig_op_contents.is_none() {
            self.sig_op_contents.set_default();
        }
        self.sig_op_contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig_op_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.sig_op_contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string operation_hash = 3;


    pub fn get_operation_hash(&self) -> &str {
        match self.operation_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operation_hash(&mut self) {
        self.operation_hash.clear();
    }

    pub fn has_operation_hash(&self) -> bool {
        self.operation_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_hash(&mut self, v: ::std::string::String) {
        self.operation_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_hash(&mut self) -> &mut ::std::string::String {
        if self.operation_hash.is_none() {
            self.operation_hash.set_default();
        }
        self.operation_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_hash(&mut self) -> ::std::string::String {
        self.operation_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosSignedTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sig_op_contents)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operation_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sig_op_contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.operation_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sig_op_contents.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.operation_hash.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignedTx {
        TezosSignedTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &TezosSignedTx| { &m.signature },
                |m: &mut TezosSignedTx| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig_op_contents",
                |m: &TezosSignedTx| { &m.sig_op_contents },
                |m: &mut TezosSignedTx| { &mut m.sig_op_contents },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation_hash",
                |m: &TezosSignedTx| { &m.operation_hash },
                |m: &mut TezosSignedTx| { &mut m.operation_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TezosSignedTx>(
                "TezosSignedTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TezosSignedTx {
        static instance: ::protobuf::rt::LazyV2<TezosSignedTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TezosSignedTx::new)
    }
}

impl ::protobuf::Clear for TezosSignedTx {
    fn clear(&mut self) {
        self.signature.clear();
        self.sig_op_contents.clear();
        self.operation_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignedTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignedTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14messages-tezos.proto\x12\x18hw.trezor.messages.tezos\"Q\n\x0fTezos\
    GetAddress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\
    \x0cshow_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\"(\n\x0cTezosAddre\
    ss\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\"S\n\x11TezosGetP\
    ublicKey\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0c\
    show_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\"/\n\x0eTezosPublicKey\
    \x12\x1d\n\npublic_key\x18\x01\x20\x01(\tR\tpublicKey\"\xa4\x14\n\x0bTez\
    osSignTx\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x16\n\
    \x06branch\x18\x02\x20\x01(\x0cR\x06branch\x12K\n\x06reveal\x18\x03\x20\
    \x01(\x0b23.hw.trezor.messages.tezos.TezosSignTx.TezosRevealOpR\x06revea\
    l\x12Z\n\x0btransaction\x18\x04\x20\x01(\x0b28.hw.trezor.messages.tezos.\
    TezosSignTx.TezosTransactionOpR\x0btransaction\x12Z\n\x0borigination\x18\
    \x05\x20\x01(\x0b28.hw.trezor.messages.tezos.TezosSignTx.TezosOriginatio\
    nOpR\x0borigination\x12W\n\ndelegation\x18\x06\x20\x01(\x0b27.hw.trezor.\
    messages.tezos.TezosSignTx.TezosDelegationOpR\ndelegation\x12Q\n\x08prop\
    osal\x18\x07\x20\x01(\x0b25.hw.trezor.messages.tezos.TezosSignTx.TezosPr\
    oposalOpR\x08proposal\x12K\n\x06ballot\x18\x08\x20\x01(\x0b23.hw.trezor.\
    messages.tezos.TezosSignTx.TezosBallotOpR\x06ballot\x1a\xb3\x01\n\x0fTez\
    osContractID\x12Y\n\x03tag\x18\x01\x20\x01(\x0e2G.hw.trezor.messages.tez\
    os.TezosSignTx.TezosContractID.TezosContractTypeR\x03tag\x12\x12\n\x04ha\
    sh\x18\x02\x20\x01(\x0cR\x04hash\"1\n\x11TezosContractType\x12\x0c\n\x08\
    Implicit\x10\0\x12\x0e\n\nOriginated\x10\x01\x1a\xb4\x01\n\rTezosRevealO\
    p\x12\x16\n\x06source\x18\x07\x20\x01(\x0cR\x06source\x12\x10\n\x03fee\
    \x18\x02\x20\x01(\x04R\x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\
    \x07counter\x12\x1b\n\tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\
    \n\rstorage_limit\x18\x05\x20\x01(\x04R\x0cstorageLimit\x12\x1d\n\npubli\
    c_key\x18\x06\x20\x01(\x0cR\tpublicKey\x1a\x9f\x06\n\x12TezosTransaction\
    Op\x12\x16\n\x06source\x18\t\x20\x01(\x0cR\x06source\x12\x10\n\x03fee\
    \x18\x02\x20\x01(\x04R\x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\
    \x07counter\x12\x1b\n\tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\
    \n\rstorage_limit\x18\x05\x20\x01(\x04R\x0cstorageLimit\x12\x16\n\x06amo\
    unt\x18\x06\x20\x01(\x04R\x06amount\x12W\n\x0bdestination\x18\x07\x20\
    \x01(\x0b25.hw.trezor.messages.tezos.TezosSignTx.TezosContractIDR\x0bdes\
    tination\x12\x1e\n\nparameters\x18\x08\x20\x01(\x0cR\nparameters\x12~\n\
    \x12parameters_manager\x18\n\x20\x01(\x0b2O.hw.trezor.messages.tezos.Tez\
    osSignTx.TezosTransactionOp.TezosParametersManagerR\x11parametersManager\
    \x1a\xf1\x02\n\x16TezosParametersManager\x12!\n\x0cset_delegate\x18\x01\
    \x20\x01(\x0cR\x0bsetDelegate\x12'\n\x0fcancel_delegate\x18\x02\x20\x01(\
    \x08R\x0ecancelDelegate\x12\x80\x01\n\x08transfer\x18\x03\x20\x01(\x0b2d\
    .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp.TezosParameters\
    Manager.TezosManagerTransferR\x08transfer\x1a\x87\x01\n\x14TezosManagerT\
    ransfer\x12W\n\x0bdestination\x18\x01\x20\x01(\x0b25.hw.trezor.messages.\
    tezos.TezosSignTx.TezosContractIDR\x0bdestination\x12\x16\n\x06amount\
    \x18\x02\x20\x01(\x04R\x06amount\x1a\xcf\x02\n\x12TezosOriginationOp\x12\
    \x16\n\x06source\x18\x0c\x20\x01(\x0cR\x06source\x12\x10\n\x03fee\x18\
    \x02\x20\x01(\x04R\x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\x07\
    counter\x12\x1b\n\tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\n\rs\
    torage_limit\x18\x05\x20\x01(\x04R\x0cstorageLimit\x12%\n\x0emanager_pub\
    key\x18\x06\x20\x01(\x0cR\rmanagerPubkey\x12\x18\n\x07balance\x18\x07\
    \x20\x01(\x04R\x07balance\x12\x1c\n\tspendable\x18\x08\x20\x01(\x08R\tsp\
    endable\x12\x20\n\x0bdelegatable\x18\t\x20\x01(\x08R\x0bdelegatable\x12\
    \x1a\n\x08delegate\x18\n\x20\x01(\x0cR\x08delegate\x12\x16\n\x06script\
    \x18\x0b\x20\x01(\x0cR\x06script\x1a\xb5\x01\n\x11TezosDelegationOp\x12\
    \x16\n\x06source\x18\x07\x20\x01(\x0cR\x06source\x12\x10\n\x03fee\x18\
    \x02\x20\x01(\x04R\x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\x07\
    counter\x12\x1b\n\tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\n\rs\
    torage_limit\x18\x05\x20\x01(\x04R\x0cstorageLimit\x12\x1a\n\x08delegate\
    \x18\x06\x20\x01(\x0cR\x08delegate\x1a_\n\x0fTezosProposalOp\x12\x16\n\
    \x06source\x18\x01\x20\x01(\x0cR\x06source\x12\x16\n\x06period\x18\x02\
    \x20\x01(\x04R\x06period\x12\x1c\n\tproposals\x18\x04\x20\x03(\x0cR\tpro\
    posals\x1a\xe7\x01\n\rTezosBallotOp\x12\x16\n\x06source\x18\x01\x20\x01(\
    \x0cR\x06source\x12\x16\n\x06period\x18\x02\x20\x01(\x04R\x06period\x12\
    \x1a\n\x08proposal\x18\x03\x20\x01(\x0cR\x08proposal\x12[\n\x06ballot\
    \x18\x04\x20\x01(\x0e2C.hw.trezor.messages.tezos.TezosSignTx.TezosBallot\
    Op.TezosBallotTypeR\x06ballot\"-\n\x0fTezosBallotType\x12\x07\n\x03Yay\
    \x10\0\x12\x07\n\x03Nay\x10\x01\x12\x08\n\x04Pass\x10\x02\"|\n\rTezosSig\
    nedTx\x12\x1c\n\tsignature\x18\x01\x20\x01(\tR\tsignature\x12&\n\x0fsig_\
    op_contents\x18\x02\x20\x01(\x0cR\rsigOpContents\x12%\n\x0eoperation_has\
    h\x18\x03\x20\x01(\tR\roperationHashB9\n#com.satoshilabs.trezor.lib.prot\
    obufB\x12TrezorMessageTezos\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
