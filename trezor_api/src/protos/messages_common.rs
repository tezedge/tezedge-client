// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Success {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Success {
    fn default() -> &'a Success {
        <Success as ::protobuf::Message>::default_instance()
    }
}

impl Success {
    pub fn new() -> Success {
        ::std::default::Default::default()
    }

    // optional string message = 1;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Success {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Success {
        Success::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Success| { &m.message },
                |m: &mut Success| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Success>(
                "Success",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Success {
        static instance: ::protobuf::rt::LazyV2<Success> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Success::new)
    }
}

impl ::protobuf::Clear for Success {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Success {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Success {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Failure {
    // message fields
    code: ::std::option::Option<Failure_FailureType>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Failure {
    fn default() -> &'a Failure {
        <Failure as ::protobuf::Message>::default_instance()
    }
}

impl Failure {
    pub fn new() -> Failure {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.Failure.FailureType code = 1;


    pub fn get_code(&self) -> Failure_FailureType {
        self.code.unwrap_or(Failure_FailureType::Failure_UnexpectedMessage)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Failure_FailureType) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Failure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.code {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Failure {
        Failure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Failure_FailureType>>(
                "code",
                |m: &Failure| { &m.code },
                |m: &mut Failure| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Failure| { &m.message },
                |m: &mut Failure| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Failure>(
                "Failure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Failure {
        static instance: ::protobuf::rt::LazyV2<Failure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Failure::new)
    }
}

impl ::protobuf::Clear for Failure {
    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Failure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Failure_FailureType {
    Failure_UnexpectedMessage = 1,
    Failure_ButtonExpected = 2,
    Failure_DataError = 3,
    Failure_ActionCancelled = 4,
    Failure_PinExpected = 5,
    Failure_PinCancelled = 6,
    Failure_PinInvalid = 7,
    Failure_InvalidSignature = 8,
    Failure_ProcessError = 9,
    Failure_NotEnoughFunds = 10,
    Failure_NotInitialized = 11,
    Failure_PinMismatch = 12,
    Failure_WipeCodeMismatch = 13,
    Failure_InvalidSession = 14,
    Failure_FirmwareError = 99,
}

impl ::protobuf::ProtobufEnum for Failure_FailureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Failure_FailureType> {
        match value {
            1 => ::std::option::Option::Some(Failure_FailureType::Failure_UnexpectedMessage),
            2 => ::std::option::Option::Some(Failure_FailureType::Failure_ButtonExpected),
            3 => ::std::option::Option::Some(Failure_FailureType::Failure_DataError),
            4 => ::std::option::Option::Some(Failure_FailureType::Failure_ActionCancelled),
            5 => ::std::option::Option::Some(Failure_FailureType::Failure_PinExpected),
            6 => ::std::option::Option::Some(Failure_FailureType::Failure_PinCancelled),
            7 => ::std::option::Option::Some(Failure_FailureType::Failure_PinInvalid),
            8 => ::std::option::Option::Some(Failure_FailureType::Failure_InvalidSignature),
            9 => ::std::option::Option::Some(Failure_FailureType::Failure_ProcessError),
            10 => ::std::option::Option::Some(Failure_FailureType::Failure_NotEnoughFunds),
            11 => ::std::option::Option::Some(Failure_FailureType::Failure_NotInitialized),
            12 => ::std::option::Option::Some(Failure_FailureType::Failure_PinMismatch),
            13 => ::std::option::Option::Some(Failure_FailureType::Failure_WipeCodeMismatch),
            14 => ::std::option::Option::Some(Failure_FailureType::Failure_InvalidSession),
            99 => ::std::option::Option::Some(Failure_FailureType::Failure_FirmwareError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Failure_FailureType] = &[
            Failure_FailureType::Failure_UnexpectedMessage,
            Failure_FailureType::Failure_ButtonExpected,
            Failure_FailureType::Failure_DataError,
            Failure_FailureType::Failure_ActionCancelled,
            Failure_FailureType::Failure_PinExpected,
            Failure_FailureType::Failure_PinCancelled,
            Failure_FailureType::Failure_PinInvalid,
            Failure_FailureType::Failure_InvalidSignature,
            Failure_FailureType::Failure_ProcessError,
            Failure_FailureType::Failure_NotEnoughFunds,
            Failure_FailureType::Failure_NotInitialized,
            Failure_FailureType::Failure_PinMismatch,
            Failure_FailureType::Failure_WipeCodeMismatch,
            Failure_FailureType::Failure_InvalidSession,
            Failure_FailureType::Failure_FirmwareError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Failure_FailureType>("Failure.FailureType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Failure_FailureType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Failure_FailureType {
    fn default() -> Self {
        Failure_FailureType::Failure_UnexpectedMessage
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure_FailureType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonRequest {
    // message fields
    code: ::std::option::Option<ButtonRequest_ButtonRequestType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ButtonRequest {
    fn default() -> &'a ButtonRequest {
        <ButtonRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonRequest {
    pub fn new() -> ButtonRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.ButtonRequest.ButtonRequestType code = 1;


    pub fn get_code(&self) -> ButtonRequest_ButtonRequestType {
        self.code.unwrap_or(ButtonRequest_ButtonRequestType::ButtonRequest_Other)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ButtonRequest_ButtonRequestType) {
        self.code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ButtonRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.code {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ButtonRequest {
        ButtonRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ButtonRequest_ButtonRequestType>>(
                "code",
                |m: &ButtonRequest| { &m.code },
                |m: &mut ButtonRequest| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ButtonRequest>(
                "ButtonRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ButtonRequest {
        static instance: ::protobuf::rt::LazyV2<ButtonRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ButtonRequest::new)
    }
}

impl ::protobuf::Clear for ButtonRequest {
    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ButtonRequest_ButtonRequestType {
    ButtonRequest_Other = 1,
    ButtonRequest_FeeOverThreshold = 2,
    ButtonRequest_ConfirmOutput = 3,
    ButtonRequest_ResetDevice = 4,
    ButtonRequest_ConfirmWord = 5,
    ButtonRequest_WipeDevice = 6,
    ButtonRequest_ProtectCall = 7,
    ButtonRequest_SignTx = 8,
    ButtonRequest_FirmwareCheck = 9,
    ButtonRequest_Address = 10,
    ButtonRequest_PublicKey = 11,
    ButtonRequest_MnemonicWordCount = 12,
    ButtonRequest_MnemonicInput = 13,
    _Deprecated_ButtonRequest_PassphraseType = 14,
    ButtonRequest_UnknownDerivationPath = 15,
    ButtonRequest_RecoveryHomepage = 16,
    ButtonRequest_Success = 17,
    ButtonRequest_Warning = 18,
    ButtonRequest_PassphraseEntry = 19,
    ButtonRequest_PinEntry = 20,
}

impl ::protobuf::ProtobufEnum for ButtonRequest_ButtonRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ButtonRequest_ButtonRequestType> {
        match value {
            1 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Other),
            2 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_FeeOverThreshold),
            3 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmOutput),
            4 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ResetDevice),
            5 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmWord),
            6 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_WipeDevice),
            7 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ProtectCall),
            8 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_SignTx),
            9 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_FirmwareCheck),
            10 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Address),
            11 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_PublicKey),
            12 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicWordCount),
            13 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicInput),
            14 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType),
            15 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_UnknownDerivationPath),
            16 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_RecoveryHomepage),
            17 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Success),
            18 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Warning),
            19 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_PassphraseEntry),
            20 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_PinEntry),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ButtonRequest_ButtonRequestType] = &[
            ButtonRequest_ButtonRequestType::ButtonRequest_Other,
            ButtonRequest_ButtonRequestType::ButtonRequest_FeeOverThreshold,
            ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmOutput,
            ButtonRequest_ButtonRequestType::ButtonRequest_ResetDevice,
            ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmWord,
            ButtonRequest_ButtonRequestType::ButtonRequest_WipeDevice,
            ButtonRequest_ButtonRequestType::ButtonRequest_ProtectCall,
            ButtonRequest_ButtonRequestType::ButtonRequest_SignTx,
            ButtonRequest_ButtonRequestType::ButtonRequest_FirmwareCheck,
            ButtonRequest_ButtonRequestType::ButtonRequest_Address,
            ButtonRequest_ButtonRequestType::ButtonRequest_PublicKey,
            ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicWordCount,
            ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicInput,
            ButtonRequest_ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType,
            ButtonRequest_ButtonRequestType::ButtonRequest_UnknownDerivationPath,
            ButtonRequest_ButtonRequestType::ButtonRequest_RecoveryHomepage,
            ButtonRequest_ButtonRequestType::ButtonRequest_Success,
            ButtonRequest_ButtonRequestType::ButtonRequest_Warning,
            ButtonRequest_ButtonRequestType::ButtonRequest_PassphraseEntry,
            ButtonRequest_ButtonRequestType::ButtonRequest_PinEntry,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ButtonRequest_ButtonRequestType>("ButtonRequest.ButtonRequestType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ButtonRequest_ButtonRequestType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ButtonRequest_ButtonRequestType {
    fn default() -> Self {
        ButtonRequest_ButtonRequestType::ButtonRequest_Other
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonRequest_ButtonRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ButtonAck {
    fn default() -> &'a ButtonAck {
        <ButtonAck as ::protobuf::Message>::default_instance()
    }
}

impl ButtonAck {
    pub fn new() -> ButtonAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ButtonAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ButtonAck {
        ButtonAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ButtonAck>(
                "ButtonAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ButtonAck {
        static instance: ::protobuf::rt::LazyV2<ButtonAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ButtonAck::new)
    }
}

impl ::protobuf::Clear for ButtonAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PinMatrixRequest {
    // message fields
    field_type: ::std::option::Option<PinMatrixRequest_PinMatrixRequestType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PinMatrixRequest {
    fn default() -> &'a PinMatrixRequest {
        <PinMatrixRequest as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixRequest {
    pub fn new() -> PinMatrixRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType type = 1;


    pub fn get_field_type(&self) -> PinMatrixRequest_PinMatrixRequestType {
        self.field_type.unwrap_or(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PinMatrixRequest_PinMatrixRequestType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PinMatrixRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PinMatrixRequest {
        PinMatrixRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PinMatrixRequest_PinMatrixRequestType>>(
                "type",
                |m: &PinMatrixRequest| { &m.field_type },
                |m: &mut PinMatrixRequest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PinMatrixRequest>(
                "PinMatrixRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PinMatrixRequest {
        static instance: ::protobuf::rt::LazyV2<PinMatrixRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PinMatrixRequest::new)
    }
}

impl ::protobuf::Clear for PinMatrixRequest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PinMatrixRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PinMatrixRequest_PinMatrixRequestType {
    PinMatrixRequestType_Current = 1,
    PinMatrixRequestType_NewFirst = 2,
    PinMatrixRequestType_NewSecond = 3,
    PinMatrixRequestType_WipeCodeFirst = 4,
    PinMatrixRequestType_WipeCodeSecond = 5,
}

impl ::protobuf::ProtobufEnum for PinMatrixRequest_PinMatrixRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PinMatrixRequest_PinMatrixRequestType> {
        match value {
            1 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current),
            2 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewFirst),
            3 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewSecond),
            4 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst),
            5 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PinMatrixRequest_PinMatrixRequestType] = &[
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewFirst,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewSecond,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PinMatrixRequest_PinMatrixRequestType>("PinMatrixRequest.PinMatrixRequestType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PinMatrixRequest_PinMatrixRequestType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PinMatrixRequest_PinMatrixRequestType {
    fn default() -> Self {
        PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixRequest_PinMatrixRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PinMatrixAck {
    // message fields
    pin: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PinMatrixAck {
    fn default() -> &'a PinMatrixAck {
        <PinMatrixAck as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixAck {
    pub fn new() -> PinMatrixAck {
        ::std::default::Default::default()
    }

    // required string pin = 1;


    pub fn get_pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PinMatrixAck {
    fn is_initialized(&self) -> bool {
        if self.pin.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pin.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PinMatrixAck {
        PinMatrixAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pin",
                |m: &PinMatrixAck| { &m.pin },
                |m: &mut PinMatrixAck| { &mut m.pin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PinMatrixAck>(
                "PinMatrixAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PinMatrixAck {
        static instance: ::protobuf::rt::LazyV2<PinMatrixAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PinMatrixAck::new)
    }
}

impl ::protobuf::Clear for PinMatrixAck {
    fn clear(&mut self) {
        self.pin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PinMatrixAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseRequest {
    // message fields
    _on_device: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseRequest {
    fn default() -> &'a PassphraseRequest {
        <PassphraseRequest as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseRequest {
    pub fn new() -> PassphraseRequest {
        ::std::default::Default::default()
    }

    // optional bool _on_device = 1;


    pub fn get__on_device(&self) -> bool {
        self._on_device.unwrap_or(false)
    }
    pub fn clear__on_device(&mut self) {
        self._on_device = ::std::option::Option::None;
    }

    pub fn has__on_device(&self) -> bool {
        self._on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set__on_device(&mut self, v: bool) {
        self._on_device = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PassphraseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self._on_device = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self._on_device {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self._on_device {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseRequest {
        PassphraseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "_on_device",
                |m: &PassphraseRequest| { &m._on_device },
                |m: &mut PassphraseRequest| { &mut m._on_device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PassphraseRequest>(
                "PassphraseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PassphraseRequest {
        static instance: ::protobuf::rt::LazyV2<PassphraseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PassphraseRequest::new)
    }
}

impl ::protobuf::Clear for PassphraseRequest {
    fn clear(&mut self) {
        self._on_device = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseAck {
    // message fields
    passphrase: ::protobuf::SingularField<::std::string::String>,
    _state: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    on_device: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseAck {
    fn default() -> &'a PassphraseAck {
        <PassphraseAck as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseAck {
    pub fn new() -> PassphraseAck {
        ::std::default::Default::default()
    }

    // optional string passphrase = 1;


    pub fn get_passphrase(&self) -> &str {
        match self.passphrase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_passphrase(&mut self) {
        self.passphrase.clear();
    }

    pub fn has_passphrase(&self) -> bool {
        self.passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase(&mut self, v: ::std::string::String) {
        self.passphrase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passphrase(&mut self) -> &mut ::std::string::String {
        if self.passphrase.is_none() {
            self.passphrase.set_default();
        }
        self.passphrase.as_mut().unwrap()
    }

    // Take field
    pub fn take_passphrase(&mut self) -> ::std::string::String {
        self.passphrase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes _state = 2;


    pub fn get__state(&self) -> &[u8] {
        match self._state.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear__state(&mut self) {
        self._state.clear();
    }

    pub fn has__state(&self) -> bool {
        self._state.is_some()
    }

    // Param is passed by value, moved
    pub fn set__state(&mut self, v: ::std::vec::Vec<u8>) {
        self._state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self._state.is_none() {
            self._state.set_default();
        }
        self._state.as_mut().unwrap()
    }

    // Take field
    pub fn take__state(&mut self) -> ::std::vec::Vec<u8> {
        self._state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool on_device = 3;


    pub fn get_on_device(&self) -> bool {
        self.on_device.unwrap_or(false)
    }
    pub fn clear_on_device(&mut self) {
        self.on_device = ::std::option::Option::None;
    }

    pub fn has_on_device(&self) -> bool {
        self.on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_on_device(&mut self, v: bool) {
        self.on_device = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PassphraseAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.passphrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self._state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.on_device = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.passphrase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self._state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.on_device {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.passphrase.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self._state.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.on_device {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseAck {
        PassphraseAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "passphrase",
                |m: &PassphraseAck| { &m.passphrase },
                |m: &mut PassphraseAck| { &mut m.passphrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "_state",
                |m: &PassphraseAck| { &m._state },
                |m: &mut PassphraseAck| { &mut m._state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "on_device",
                |m: &PassphraseAck| { &m.on_device },
                |m: &mut PassphraseAck| { &mut m.on_device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PassphraseAck>(
                "PassphraseAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PassphraseAck {
        static instance: ::protobuf::rt::LazyV2<PassphraseAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PassphraseAck::new)
    }
}

impl ::protobuf::Clear for PassphraseAck {
    fn clear(&mut self) {
        self.passphrase.clear();
        self._state.clear();
        self.on_device = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Deprecated_PassphraseStateRequest {
    // message fields
    state: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Deprecated_PassphraseStateRequest {
    fn default() -> &'a Deprecated_PassphraseStateRequest {
        <Deprecated_PassphraseStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl Deprecated_PassphraseStateRequest {
    pub fn new() -> Deprecated_PassphraseStateRequest {
        ::std::default::Default::default()
    }

    // optional bytes state = 1;


    pub fn get_state(&self) -> &[u8] {
        match self.state.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        self.state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Deprecated_PassphraseStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Deprecated_PassphraseStateRequest {
        Deprecated_PassphraseStateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state",
                |m: &Deprecated_PassphraseStateRequest| { &m.state },
                |m: &mut Deprecated_PassphraseStateRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Deprecated_PassphraseStateRequest>(
                "Deprecated_PassphraseStateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Deprecated_PassphraseStateRequest {
        static instance: ::protobuf::rt::LazyV2<Deprecated_PassphraseStateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Deprecated_PassphraseStateRequest::new)
    }
}

impl ::protobuf::Clear for Deprecated_PassphraseStateRequest {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Deprecated_PassphraseStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deprecated_PassphraseStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Deprecated_PassphraseStateAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Deprecated_PassphraseStateAck {
    fn default() -> &'a Deprecated_PassphraseStateAck {
        <Deprecated_PassphraseStateAck as ::protobuf::Message>::default_instance()
    }
}

impl Deprecated_PassphraseStateAck {
    pub fn new() -> Deprecated_PassphraseStateAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Deprecated_PassphraseStateAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Deprecated_PassphraseStateAck {
        Deprecated_PassphraseStateAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Deprecated_PassphraseStateAck>(
                "Deprecated_PassphraseStateAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Deprecated_PassphraseStateAck {
        static instance: ::protobuf::rt::LazyV2<Deprecated_PassphraseStateAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Deprecated_PassphraseStateAck::new)
    }
}

impl ::protobuf::Clear for Deprecated_PassphraseStateAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Deprecated_PassphraseStateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deprecated_PassphraseStateAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HDNodeType {
    // message fields
    depth: ::std::option::Option<u32>,
    fingerprint: ::std::option::Option<u32>,
    child_num: ::std::option::Option<u32>,
    chain_code: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    private_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HDNodeType {
    fn default() -> &'a HDNodeType {
        <HDNodeType as ::protobuf::Message>::default_instance()
    }
}

impl HDNodeType {
    pub fn new() -> HDNodeType {
        ::std::default::Default::default()
    }

    // required uint32 depth = 1;


    pub fn get_depth(&self) -> u32 {
        self.depth.unwrap_or(0)
    }
    pub fn clear_depth(&mut self) {
        self.depth = ::std::option::Option::None;
    }

    pub fn has_depth(&self) -> bool {
        self.depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: u32) {
        self.depth = ::std::option::Option::Some(v);
    }

    // required uint32 fingerprint = 2;


    pub fn get_fingerprint(&self) -> u32 {
        self.fingerprint.unwrap_or(0)
    }
    pub fn clear_fingerprint(&mut self) {
        self.fingerprint = ::std::option::Option::None;
    }

    pub fn has_fingerprint(&self) -> bool {
        self.fingerprint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerprint(&mut self, v: u32) {
        self.fingerprint = ::std::option::Option::Some(v);
    }

    // required uint32 child_num = 3;


    pub fn get_child_num(&self) -> u32 {
        self.child_num.unwrap_or(0)
    }
    pub fn clear_child_num(&mut self) {
        self.child_num = ::std::option::Option::None;
    }

    pub fn has_child_num(&self) -> bool {
        self.child_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_num(&mut self, v: u32) {
        self.child_num = ::std::option::Option::Some(v);
    }

    // required bytes chain_code = 4;


    pub fn get_chain_code(&self) -> &[u8] {
        match self.chain_code.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_chain_code(&mut self) {
        self.chain_code.clear();
    }

    pub fn has_chain_code(&self) -> bool {
        self.chain_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chain_code.is_none() {
            self.chain_code.set_default();
        }
        self.chain_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain_code(&mut self) -> ::std::vec::Vec<u8> {
        self.chain_code.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes private_key = 5;


    pub fn get_private_key(&self) -> &[u8] {
        match self.private_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_private_key(&mut self) {
        self.private_key.clear();
    }

    pub fn has_private_key(&self) -> bool {
        self.private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.private_key.is_none() {
            self.private_key.set_default();
        }
        self.private_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_key(&mut self) -> ::std::vec::Vec<u8> {
        self.private_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes public_key = 6;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HDNodeType {
    fn is_initialized(&self) -> bool {
        if self.depth.is_none() {
            return false;
        }
        if self.fingerprint.is_none() {
            return false;
        }
        if self.child_num.is_none() {
            return false;
        }
        if self.chain_code.is_none() {
            return false;
        }
        if self.public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depth = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fingerprint = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.child_num = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.chain_code)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.private_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerprint {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_num {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chain_code.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.private_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depth {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerprint {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.child_num {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.chain_code.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.private_key.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HDNodeType {
        HDNodeType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depth",
                |m: &HDNodeType| { &m.depth },
                |m: &mut HDNodeType| { &mut m.depth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fingerprint",
                |m: &HDNodeType| { &m.fingerprint },
                |m: &mut HDNodeType| { &mut m.fingerprint },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "child_num",
                |m: &HDNodeType| { &m.child_num },
                |m: &mut HDNodeType| { &mut m.child_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chain_code",
                |m: &HDNodeType| { &m.chain_code },
                |m: &mut HDNodeType| { &mut m.chain_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "private_key",
                |m: &HDNodeType| { &m.private_key },
                |m: &mut HDNodeType| { &mut m.private_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "public_key",
                |m: &HDNodeType| { &m.public_key },
                |m: &mut HDNodeType| { &mut m.public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HDNodeType>(
                "HDNodeType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HDNodeType {
        static instance: ::protobuf::rt::LazyV2<HDNodeType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HDNodeType::new)
    }
}

impl ::protobuf::Clear for HDNodeType {
    fn clear(&mut self) {
        self.depth = ::std::option::Option::None;
        self.fingerprint = ::std::option::Option::None;
        self.child_num = ::std::option::Option::None;
        self.chain_code.clear();
        self.private_key.clear();
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HDNodeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HDNodeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-common.proto\x12\x19hw.trezor.messages.common\"#\n\x07Suc\
    cess\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\x8f\x04\n\x07\
    Failure\x12B\n\x04code\x18\x01\x20\x01(\x0e2..hw.trezor.messages.common.\
    Failure.FailureTypeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\"\xa5\x03\n\x0bFailureType\x12\x1d\n\x19Failure_UnexpectedMe\
    ssage\x10\x01\x12\x1a\n\x16Failure_ButtonExpected\x10\x02\x12\x15\n\x11F\
    ailure_DataError\x10\x03\x12\x1b\n\x17Failure_ActionCancelled\x10\x04\
    \x12\x17\n\x13Failure_PinExpected\x10\x05\x12\x18\n\x14Failure_PinCancel\
    led\x10\x06\x12\x16\n\x12Failure_PinInvalid\x10\x07\x12\x1c\n\x18Failure\
    _InvalidSignature\x10\x08\x12\x18\n\x14Failure_ProcessError\x10\t\x12\
    \x1a\n\x16Failure_NotEnoughFunds\x10\n\x12\x1a\n\x16Failure_NotInitializ\
    ed\x10\x0b\x12\x17\n\x13Failure_PinMismatch\x10\x0c\x12\x1c\n\x18Failure\
    _WipeCodeMismatch\x10\r\x12\x1a\n\x16Failure_InvalidSession\x10\x0e\x12\
    \x19\n\x15Failure_FirmwareError\x10c\"\xfb\x05\n\rButtonRequest\x12N\n\
    \x04code\x18\x01\x20\x01(\x0e2:.hw.trezor.messages.common.ButtonRequest.\
    ButtonRequestTypeR\x04code\"\x99\x05\n\x11ButtonRequestType\x12\x17\n\
    \x13ButtonRequest_Other\x10\x01\x12\"\n\x1eButtonRequest_FeeOverThreshol\
    d\x10\x02\x12\x1f\n\x1bButtonRequest_ConfirmOutput\x10\x03\x12\x1d\n\x19\
    ButtonRequest_ResetDevice\x10\x04\x12\x1d\n\x19ButtonRequest_ConfirmWord\
    \x10\x05\x12\x1c\n\x18ButtonRequest_WipeDevice\x10\x06\x12\x1d\n\x19Butt\
    onRequest_ProtectCall\x10\x07\x12\x18\n\x14ButtonRequest_SignTx\x10\x08\
    \x12\x1f\n\x1bButtonRequest_FirmwareCheck\x10\t\x12\x19\n\x15ButtonReque\
    st_Address\x10\n\x12\x1b\n\x17ButtonRequest_PublicKey\x10\x0b\x12#\n\x1f\
    ButtonRequest_MnemonicWordCount\x10\x0c\x12\x1f\n\x1bButtonRequest_Mnemo\
    nicInput\x10\r\x120\n(_Deprecated_ButtonRequest_PassphraseType\x10\x0e\
    \x1a\x02\x08\x01\x12'\n#ButtonRequest_UnknownDerivationPath\x10\x0f\x12\
    \"\n\x1eButtonRequest_RecoveryHomepage\x10\x10\x12\x19\n\x15ButtonReques\
    t_Success\x10\x11\x12\x19\n\x15ButtonRequest_Warning\x10\x12\x12!\n\x1dB\
    uttonRequest_PassphraseEntry\x10\x13\x12\x1a\n\x16ButtonRequest_PinEntry\
    \x10\x14\"\x0b\n\tButtonAck\"\xbb\x02\n\x10PinMatrixRequest\x12T\n\x04ty\
    pe\x18\x01\x20\x01(\x0e2@.hw.trezor.messages.common.PinMatrixRequest.Pin\
    MatrixRequestTypeR\x04type\"\xd0\x01\n\x14PinMatrixRequestType\x12\x20\n\
    \x1cPinMatrixRequestType_Current\x10\x01\x12!\n\x1dPinMatrixRequestType_\
    NewFirst\x10\x02\x12\"\n\x1ePinMatrixRequestType_NewSecond\x10\x03\x12&\
    \n\"PinMatrixRequestType_WipeCodeFirst\x10\x04\x12'\n#PinMatrixRequestTy\
    pe_WipeCodeSecond\x10\x05\"\x20\n\x0cPinMatrixAck\x12\x10\n\x03pin\x18\
    \x01\x20\x02(\tR\x03pin\"5\n\x11PassphraseRequest\x12\x20\n\n_on_device\
    \x18\x01\x20\x01(\x08R\x08OnDeviceB\x02\x18\x01\"g\n\rPassphraseAck\x12\
    \x1e\n\npassphrase\x18\x01\x20\x01(\tR\npassphrase\x12\x19\n\x06_state\
    \x18\x02\x20\x01(\x0cR\x05StateB\x02\x18\x01\x12\x1b\n\ton_device\x18\
    \x03\x20\x01(\x08R\x08onDevice\"=\n!Deprecated_PassphraseStateRequest\
    \x12\x14\n\x05state\x18\x01\x20\x01(\x0cR\x05state:\x02\x18\x01\"#\n\x1d\
    Deprecated_PassphraseStateAck:\x02\x18\x01\"\xc0\x01\n\nHDNodeType\x12\
    \x14\n\x05depth\x18\x01\x20\x02(\rR\x05depth\x12\x20\n\x0bfingerprint\
    \x18\x02\x20\x02(\rR\x0bfingerprint\x12\x1b\n\tchild_num\x18\x03\x20\x02\
    (\rR\x08childNum\x12\x1d\n\nchain_code\x18\x04\x20\x02(\x0cR\tchainCode\
    \x12\x1f\n\x0bprivate_key\x18\x05\x20\x01(\x0cR\nprivateKey\x12\x1d\n\np\
    ublic_key\x18\x06\x20\x02(\x0cR\tpublicKeyB:\n#com.satoshilabs.trezor.li\
    b.protobufB\x13TrezorMessageCommon\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
