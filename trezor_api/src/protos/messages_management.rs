// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-management.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Initialize {
    // message fields
    session_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Initialize {
    fn default() -> &'a Initialize {
        <Initialize as ::protobuf::Message>::default_instance()
    }
}

impl Initialize {
    pub fn new() -> Initialize {
        ::std::default::Default::default()
    }

    // optional bytes session_id = 1;


    pub fn get_session_id(&self) -> &[u8] {
        match self.session_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_id.is_none() {
            self.session_id.set_default();
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Initialize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.session_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Initialize {
        Initialize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "session_id",
                |m: &Initialize| { &m.session_id },
                |m: &mut Initialize| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Initialize>(
                "Initialize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Initialize {
        static instance: ::protobuf::rt::LazyV2<Initialize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Initialize::new)
    }
}

impl ::protobuf::Clear for Initialize {
    fn clear(&mut self) {
        self.session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Initialize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initialize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatures {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFeatures {
    fn default() -> &'a GetFeatures {
        <GetFeatures as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatures {
    pub fn new() -> GetFeatures {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFeatures {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatures {
        GetFeatures::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFeatures>(
                "GetFeatures",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFeatures {
        static instance: ::protobuf::rt::LazyV2<GetFeatures> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFeatures::new)
    }
}

impl ::protobuf::Clear for GetFeatures {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatures {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Features {
    // message fields
    vendor: ::protobuf::SingularField<::std::string::String>,
    major_version: ::std::option::Option<u32>,
    minor_version: ::std::option::Option<u32>,
    patch_version: ::std::option::Option<u32>,
    bootloader_mode: ::std::option::Option<bool>,
    device_id: ::protobuf::SingularField<::std::string::String>,
    pin_protection: ::std::option::Option<bool>,
    passphrase_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    initialized: ::std::option::Option<bool>,
    revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bootloader_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    imported: ::std::option::Option<bool>,
    unlocked: ::std::option::Option<bool>,
    firmware_present: ::std::option::Option<bool>,
    needs_backup: ::std::option::Option<bool>,
    flags: ::std::option::Option<u32>,
    model: ::protobuf::SingularField<::std::string::String>,
    fw_major: ::std::option::Option<u32>,
    fw_minor: ::std::option::Option<u32>,
    fw_patch: ::std::option::Option<u32>,
    fw_vendor: ::protobuf::SingularField<::std::string::String>,
    fw_vendor_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unfinished_backup: ::std::option::Option<bool>,
    no_backup: ::std::option::Option<bool>,
    recovery_mode: ::std::option::Option<bool>,
    pub capabilities: ::std::vec::Vec<Features_Capability>,
    backup_type: ::std::option::Option<BackupType>,
    sd_card_present: ::std::option::Option<bool>,
    sd_protection: ::std::option::Option<bool>,
    wipe_code_protection: ::std::option::Option<bool>,
    session_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    passphrase_always_on_device: ::std::option::Option<bool>,
    safety_checks: ::std::option::Option<SafetyCheckLevel>,
    auto_lock_delay_ms: ::std::option::Option<u32>,
    display_rotation: ::std::option::Option<u32>,
    experimental_features: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Features {
    fn default() -> &'a Features {
        <Features as ::protobuf::Message>::default_instance()
    }
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    // optional string vendor = 1;


    pub fn get_vendor(&self) -> &str {
        match self.vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vendor(&mut self) {
        self.vendor.clear();
    }

    pub fn has_vendor(&self) -> bool {
        self.vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self.vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
        if self.vendor.is_none() {
            self.vendor.set_default();
        }
        self.vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 major_version = 2;


    pub fn get_major_version(&self) -> u32 {
        self.major_version.unwrap_or(0)
    }
    pub fn clear_major_version(&mut self) {
        self.major_version = ::std::option::Option::None;
    }

    pub fn has_major_version(&self) -> bool {
        self.major_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_version(&mut self, v: u32) {
        self.major_version = ::std::option::Option::Some(v);
    }

    // optional uint32 minor_version = 3;


    pub fn get_minor_version(&self) -> u32 {
        self.minor_version.unwrap_or(0)
    }
    pub fn clear_minor_version(&mut self) {
        self.minor_version = ::std::option::Option::None;
    }

    pub fn has_minor_version(&self) -> bool {
        self.minor_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_version(&mut self, v: u32) {
        self.minor_version = ::std::option::Option::Some(v);
    }

    // optional uint32 patch_version = 4;


    pub fn get_patch_version(&self) -> u32 {
        self.patch_version.unwrap_or(0)
    }
    pub fn clear_patch_version(&mut self) {
        self.patch_version = ::std::option::Option::None;
    }

    pub fn has_patch_version(&self) -> bool {
        self.patch_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_version(&mut self, v: u32) {
        self.patch_version = ::std::option::Option::Some(v);
    }

    // optional bool bootloader_mode = 5;


    pub fn get_bootloader_mode(&self) -> bool {
        self.bootloader_mode.unwrap_or(false)
    }
    pub fn clear_bootloader_mode(&mut self) {
        self.bootloader_mode = ::std::option::Option::None;
    }

    pub fn has_bootloader_mode(&self) -> bool {
        self.bootloader_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_mode(&mut self, v: bool) {
        self.bootloader_mode = ::std::option::Option::Some(v);
    }

    // optional string device_id = 6;


    pub fn get_device_id(&self) -> &str {
        match self.device_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        if self.device_id.is_none() {
            self.device_id.set_default();
        }
        self.device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        self.device_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool pin_protection = 7;


    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }
    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 8;


    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }
    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 9;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 10;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool initialized = 12;


    pub fn get_initialized(&self) -> bool {
        self.initialized.unwrap_or(false)
    }
    pub fn clear_initialized(&mut self) {
        self.initialized = ::std::option::Option::None;
    }

    pub fn has_initialized(&self) -> bool {
        self.initialized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialized(&mut self, v: bool) {
        self.initialized = ::std::option::Option::Some(v);
    }

    // optional bytes revision = 13;


    pub fn get_revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes bootloader_hash = 14;


    pub fn get_bootloader_hash(&self) -> &[u8] {
        match self.bootloader_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_bootloader_hash(&mut self) {
        self.bootloader_hash.clear();
    }

    pub fn has_bootloader_hash(&self) -> bool {
        self.bootloader_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.bootloader_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootloader_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bootloader_hash.is_none() {
            self.bootloader_hash.set_default();
        }
        self.bootloader_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootloader_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.bootloader_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool imported = 15;


    pub fn get_imported(&self) -> bool {
        self.imported.unwrap_or(false)
    }
    pub fn clear_imported(&mut self) {
        self.imported = ::std::option::Option::None;
    }

    pub fn has_imported(&self) -> bool {
        self.imported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imported(&mut self, v: bool) {
        self.imported = ::std::option::Option::Some(v);
    }

    // optional bool unlocked = 16;


    pub fn get_unlocked(&self) -> bool {
        self.unlocked.unwrap_or(false)
    }
    pub fn clear_unlocked(&mut self) {
        self.unlocked = ::std::option::Option::None;
    }

    pub fn has_unlocked(&self) -> bool {
        self.unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlocked(&mut self, v: bool) {
        self.unlocked = ::std::option::Option::Some(v);
    }

    // optional bool firmware_present = 18;


    pub fn get_firmware_present(&self) -> bool {
        self.firmware_present.unwrap_or(false)
    }
    pub fn clear_firmware_present(&mut self) {
        self.firmware_present = ::std::option::Option::None;
    }

    pub fn has_firmware_present(&self) -> bool {
        self.firmware_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmware_present(&mut self, v: bool) {
        self.firmware_present = ::std::option::Option::Some(v);
    }

    // optional bool needs_backup = 19;


    pub fn get_needs_backup(&self) -> bool {
        self.needs_backup.unwrap_or(false)
    }
    pub fn clear_needs_backup(&mut self) {
        self.needs_backup = ::std::option::Option::None;
    }

    pub fn has_needs_backup(&self) -> bool {
        self.needs_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_backup(&mut self, v: bool) {
        self.needs_backup = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 20;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string model = 21;


    pub fn get_model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        self.model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 fw_major = 22;


    pub fn get_fw_major(&self) -> u32 {
        self.fw_major.unwrap_or(0)
    }
    pub fn clear_fw_major(&mut self) {
        self.fw_major = ::std::option::Option::None;
    }

    pub fn has_fw_major(&self) -> bool {
        self.fw_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_major(&mut self, v: u32) {
        self.fw_major = ::std::option::Option::Some(v);
    }

    // optional uint32 fw_minor = 23;


    pub fn get_fw_minor(&self) -> u32 {
        self.fw_minor.unwrap_or(0)
    }
    pub fn clear_fw_minor(&mut self) {
        self.fw_minor = ::std::option::Option::None;
    }

    pub fn has_fw_minor(&self) -> bool {
        self.fw_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_minor(&mut self, v: u32) {
        self.fw_minor = ::std::option::Option::Some(v);
    }

    // optional uint32 fw_patch = 24;


    pub fn get_fw_patch(&self) -> u32 {
        self.fw_patch.unwrap_or(0)
    }
    pub fn clear_fw_patch(&mut self) {
        self.fw_patch = ::std::option::Option::None;
    }

    pub fn has_fw_patch(&self) -> bool {
        self.fw_patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_patch(&mut self, v: u32) {
        self.fw_patch = ::std::option::Option::Some(v);
    }

    // optional string fw_vendor = 25;


    pub fn get_fw_vendor(&self) -> &str {
        match self.fw_vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fw_vendor(&mut self) {
        self.fw_vendor.clear();
    }

    pub fn has_fw_vendor(&self) -> bool {
        self.fw_vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_vendor(&mut self, v: ::std::string::String) {
        self.fw_vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fw_vendor(&mut self) -> &mut ::std::string::String {
        if self.fw_vendor.is_none() {
            self.fw_vendor.set_default();
        }
        self.fw_vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_fw_vendor(&mut self) -> ::std::string::String {
        self.fw_vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fw_vendor_keys = 26;


    pub fn get_fw_vendor_keys(&self) -> &[u8] {
        match self.fw_vendor_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_fw_vendor_keys(&mut self) {
        self.fw_vendor_keys.clear();
    }

    pub fn has_fw_vendor_keys(&self) -> bool {
        self.fw_vendor_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_vendor_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.fw_vendor_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fw_vendor_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fw_vendor_keys.is_none() {
            self.fw_vendor_keys.set_default();
        }
        self.fw_vendor_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_fw_vendor_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.fw_vendor_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool unfinished_backup = 27;


    pub fn get_unfinished_backup(&self) -> bool {
        self.unfinished_backup.unwrap_or(false)
    }
    pub fn clear_unfinished_backup(&mut self) {
        self.unfinished_backup = ::std::option::Option::None;
    }

    pub fn has_unfinished_backup(&self) -> bool {
        self.unfinished_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unfinished_backup(&mut self, v: bool) {
        self.unfinished_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 28;


    pub fn get_no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }
    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    // optional bool recovery_mode = 29;


    pub fn get_recovery_mode(&self) -> bool {
        self.recovery_mode.unwrap_or(false)
    }
    pub fn clear_recovery_mode(&mut self) {
        self.recovery_mode = ::std::option::Option::None;
    }

    pub fn has_recovery_mode(&self) -> bool {
        self.recovery_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recovery_mode(&mut self, v: bool) {
        self.recovery_mode = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;


    pub fn get_capabilities(&self) -> &[Features_Capability] {
        &self.capabilities
    }
    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::std::vec::Vec<Features_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::std::vec::Vec<Features_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::std::vec::Vec<Features_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.management.BackupType backup_type = 31;


    pub fn get_backup_type(&self) -> BackupType {
        self.backup_type.unwrap_or(BackupType::Bip39)
    }
    pub fn clear_backup_type(&mut self) {
        self.backup_type = ::std::option::Option::None;
    }

    pub fn has_backup_type(&self) -> bool {
        self.backup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup_type(&mut self, v: BackupType) {
        self.backup_type = ::std::option::Option::Some(v);
    }

    // optional bool sd_card_present = 32;


    pub fn get_sd_card_present(&self) -> bool {
        self.sd_card_present.unwrap_or(false)
    }
    pub fn clear_sd_card_present(&mut self) {
        self.sd_card_present = ::std::option::Option::None;
    }

    pub fn has_sd_card_present(&self) -> bool {
        self.sd_card_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sd_card_present(&mut self, v: bool) {
        self.sd_card_present = ::std::option::Option::Some(v);
    }

    // optional bool sd_protection = 33;


    pub fn get_sd_protection(&self) -> bool {
        self.sd_protection.unwrap_or(false)
    }
    pub fn clear_sd_protection(&mut self) {
        self.sd_protection = ::std::option::Option::None;
    }

    pub fn has_sd_protection(&self) -> bool {
        self.sd_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sd_protection(&mut self, v: bool) {
        self.sd_protection = ::std::option::Option::Some(v);
    }

    // optional bool wipe_code_protection = 34;


    pub fn get_wipe_code_protection(&self) -> bool {
        self.wipe_code_protection.unwrap_or(false)
    }
    pub fn clear_wipe_code_protection(&mut self) {
        self.wipe_code_protection = ::std::option::Option::None;
    }

    pub fn has_wipe_code_protection(&self) -> bool {
        self.wipe_code_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wipe_code_protection(&mut self, v: bool) {
        self.wipe_code_protection = ::std::option::Option::Some(v);
    }

    // optional bytes session_id = 35;


    pub fn get_session_id(&self) -> &[u8] {
        match self.session_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_id.is_none() {
            self.session_id.set_default();
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool passphrase_always_on_device = 36;


    pub fn get_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.unwrap_or(false)
    }
    pub fn clear_passphrase_always_on_device(&mut self) {
        self.passphrase_always_on_device = ::std::option::Option::None;
    }

    pub fn has_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_always_on_device(&mut self, v: bool) {
        self.passphrase_always_on_device = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;


    pub fn get_safety_checks(&self) -> SafetyCheckLevel {
        self.safety_checks.unwrap_or(SafetyCheckLevel::Strict)
    }
    pub fn clear_safety_checks(&mut self) {
        self.safety_checks = ::std::option::Option::None;
    }

    pub fn has_safety_checks(&self) -> bool {
        self.safety_checks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_safety_checks(&mut self, v: SafetyCheckLevel) {
        self.safety_checks = ::std::option::Option::Some(v);
    }

    // optional uint32 auto_lock_delay_ms = 38;


    pub fn get_auto_lock_delay_ms(&self) -> u32 {
        self.auto_lock_delay_ms.unwrap_or(0)
    }
    pub fn clear_auto_lock_delay_ms(&mut self) {
        self.auto_lock_delay_ms = ::std::option::Option::None;
    }

    pub fn has_auto_lock_delay_ms(&self) -> bool {
        self.auto_lock_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_lock_delay_ms(&mut self, v: u32) {
        self.auto_lock_delay_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 display_rotation = 39;


    pub fn get_display_rotation(&self) -> u32 {
        self.display_rotation.unwrap_or(0)
    }
    pub fn clear_display_rotation(&mut self) {
        self.display_rotation = ::std::option::Option::None;
    }

    pub fn has_display_rotation(&self) -> bool {
        self.display_rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rotation(&mut self, v: u32) {
        self.display_rotation = ::std::option::Option::Some(v);
    }

    // optional bool experimental_features = 40;


    pub fn get_experimental_features(&self) -> bool {
        self.experimental_features.unwrap_or(false)
    }
    pub fn clear_experimental_features(&mut self) {
        self.experimental_features = ::std::option::Option::None;
    }

    pub fn has_experimental_features(&self) -> bool {
        self.experimental_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_features(&mut self, v: bool) {
        self.experimental_features = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Features {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vendor)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.major_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minor_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.patch_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bootloader_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.initialized = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.revision)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bootloader_hash)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.imported = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unlocked = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.firmware_present = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_backup = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_major = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_minor = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_patch = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fw_vendor)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fw_vendor_keys)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unfinished_backup = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_backup = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recovery_mode = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.capabilities, 30, &mut self.unknown_fields)?
                },
                31 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.backup_type, 31, &mut self.unknown_fields)?
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sd_card_present = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sd_protection = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wipe_code_protection = ::std::option::Option::Some(tmp);
                },
                35 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.session_id)?;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_always_on_device = ::std::option::Option::Some(tmp);
                },
                37 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.safety_checks, 37, &mut self.unknown_fields)?
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auto_lock_delay_ms = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.display_rotation = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.experimental_features = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.major_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.patch_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bootloader_mode {
            my_size += 2;
        }
        if let Some(ref v) = self.device_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.initialized {
            my_size += 2;
        }
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(ref v) = self.bootloader_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.imported {
            my_size += 2;
        }
        if let Some(v) = self.unlocked {
            my_size += 3;
        }
        if let Some(v) = self.firmware_present {
            my_size += 3;
        }
        if let Some(v) = self.needs_backup {
            my_size += 3;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.fw_major {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fw_minor {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fw_patch {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fw_vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(ref v) = self.fw_vendor_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(26, &v);
        }
        if let Some(v) = self.unfinished_backup {
            my_size += 3;
        }
        if let Some(v) = self.no_backup {
            my_size += 3;
        }
        if let Some(v) = self.recovery_mode {
            my_size += 3;
        }
        for value in &self.capabilities {
            my_size += ::protobuf::rt::enum_size(30, *value);
        };
        if let Some(v) = self.backup_type {
            my_size += ::protobuf::rt::enum_size(31, v);
        }
        if let Some(v) = self.sd_card_present {
            my_size += 3;
        }
        if let Some(v) = self.sd_protection {
            my_size += 3;
        }
        if let Some(v) = self.wipe_code_protection {
            my_size += 3;
        }
        if let Some(ref v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(35, &v);
        }
        if let Some(v) = self.passphrase_always_on_device {
            my_size += 3;
        }
        if let Some(v) = self.safety_checks {
            my_size += ::protobuf::rt::enum_size(37, v);
        }
        if let Some(v) = self.auto_lock_delay_ms {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_rotation {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.experimental_features {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vendor.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.major_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minor_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.patch_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bootloader_mode {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.device_id.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.initialized {
            os.write_bool(12, v)?;
        }
        if let Some(ref v) = self.revision.as_ref() {
            os.write_bytes(13, &v)?;
        }
        if let Some(ref v) = self.bootloader_hash.as_ref() {
            os.write_bytes(14, &v)?;
        }
        if let Some(v) = self.imported {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.unlocked {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.firmware_present {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.needs_backup {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(20, v)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.fw_major {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.fw_minor {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.fw_patch {
            os.write_uint32(24, v)?;
        }
        if let Some(ref v) = self.fw_vendor.as_ref() {
            os.write_string(25, &v)?;
        }
        if let Some(ref v) = self.fw_vendor_keys.as_ref() {
            os.write_bytes(26, &v)?;
        }
        if let Some(v) = self.unfinished_backup {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.recovery_mode {
            os.write_bool(29, v)?;
        }
        for v in &self.capabilities {
            os.write_enum(30, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.backup_type {
            os.write_enum(31, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.sd_card_present {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.sd_protection {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.wipe_code_protection {
            os.write_bool(34, v)?;
        }
        if let Some(ref v) = self.session_id.as_ref() {
            os.write_bytes(35, &v)?;
        }
        if let Some(v) = self.passphrase_always_on_device {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.safety_checks {
            os.write_enum(37, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.auto_lock_delay_ms {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.display_rotation {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.experimental_features {
            os.write_bool(40, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Features {
        Features::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vendor",
                |m: &Features| { &m.vendor },
                |m: &mut Features| { &mut m.vendor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "major_version",
                |m: &Features| { &m.major_version },
                |m: &mut Features| { &mut m.major_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minor_version",
                |m: &Features| { &m.minor_version },
                |m: &mut Features| { &mut m.minor_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "patch_version",
                |m: &Features| { &m.patch_version },
                |m: &mut Features| { &mut m.patch_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bootloader_mode",
                |m: &Features| { &m.bootloader_mode },
                |m: &mut Features| { &mut m.bootloader_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_id",
                |m: &Features| { &m.device_id },
                |m: &mut Features| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pin_protection",
                |m: &Features| { &m.pin_protection },
                |m: &mut Features| { &mut m.pin_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_protection",
                |m: &Features| { &m.passphrase_protection },
                |m: &mut Features| { &mut m.passphrase_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &Features| { &m.language },
                |m: &mut Features| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Features| { &m.label },
                |m: &mut Features| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "initialized",
                |m: &Features| { &m.initialized },
                |m: &mut Features| { &mut m.initialized },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "revision",
                |m: &Features| { &m.revision },
                |m: &mut Features| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bootloader_hash",
                |m: &Features| { &m.bootloader_hash },
                |m: &mut Features| { &mut m.bootloader_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "imported",
                |m: &Features| { &m.imported },
                |m: &mut Features| { &mut m.imported },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unlocked",
                |m: &Features| { &m.unlocked },
                |m: &mut Features| { &mut m.unlocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "firmware_present",
                |m: &Features| { &m.firmware_present },
                |m: &mut Features| { &mut m.firmware_present },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_backup",
                |m: &Features| { &m.needs_backup },
                |m: &mut Features| { &mut m.needs_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &Features| { &m.flags },
                |m: &mut Features| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &Features| { &m.model },
                |m: &mut Features| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fw_major",
                |m: &Features| { &m.fw_major },
                |m: &mut Features| { &mut m.fw_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fw_minor",
                |m: &Features| { &m.fw_minor },
                |m: &mut Features| { &mut m.fw_minor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fw_patch",
                |m: &Features| { &m.fw_patch },
                |m: &mut Features| { &mut m.fw_patch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fw_vendor",
                |m: &Features| { &m.fw_vendor },
                |m: &mut Features| { &mut m.fw_vendor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fw_vendor_keys",
                |m: &Features| { &m.fw_vendor_keys },
                |m: &mut Features| { &mut m.fw_vendor_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unfinished_backup",
                |m: &Features| { &m.unfinished_backup },
                |m: &mut Features| { &mut m.unfinished_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_backup",
                |m: &Features| { &m.no_backup },
                |m: &mut Features| { &mut m.no_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recovery_mode",
                |m: &Features| { &m.recovery_mode },
                |m: &mut Features| { &mut m.recovery_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Features_Capability>>(
                "capabilities",
                |m: &Features| { &m.capabilities },
                |m: &mut Features| { &mut m.capabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BackupType>>(
                "backup_type",
                |m: &Features| { &m.backup_type },
                |m: &mut Features| { &mut m.backup_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sd_card_present",
                |m: &Features| { &m.sd_card_present },
                |m: &mut Features| { &mut m.sd_card_present },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sd_protection",
                |m: &Features| { &m.sd_protection },
                |m: &mut Features| { &mut m.sd_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wipe_code_protection",
                |m: &Features| { &m.wipe_code_protection },
                |m: &mut Features| { &mut m.wipe_code_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "session_id",
                |m: &Features| { &m.session_id },
                |m: &mut Features| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_always_on_device",
                |m: &Features| { &m.passphrase_always_on_device },
                |m: &mut Features| { &mut m.passphrase_always_on_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafetyCheckLevel>>(
                "safety_checks",
                |m: &Features| { &m.safety_checks },
                |m: &mut Features| { &mut m.safety_checks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "auto_lock_delay_ms",
                |m: &Features| { &m.auto_lock_delay_ms },
                |m: &mut Features| { &mut m.auto_lock_delay_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "display_rotation",
                |m: &Features| { &m.display_rotation },
                |m: &mut Features| { &mut m.display_rotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "experimental_features",
                |m: &Features| { &m.experimental_features },
                |m: &mut Features| { &mut m.experimental_features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Features>(
                "Features",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Features {
        static instance: ::protobuf::rt::LazyV2<Features> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Features::new)
    }
}

impl ::protobuf::Clear for Features {
    fn clear(&mut self) {
        self.vendor.clear();
        self.major_version = ::std::option::Option::None;
        self.minor_version = ::std::option::Option::None;
        self.patch_version = ::std::option::Option::None;
        self.bootloader_mode = ::std::option::Option::None;
        self.device_id.clear();
        self.pin_protection = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.language.clear();
        self.label.clear();
        self.initialized = ::std::option::Option::None;
        self.revision.clear();
        self.bootloader_hash.clear();
        self.imported = ::std::option::Option::None;
        self.unlocked = ::std::option::Option::None;
        self.firmware_present = ::std::option::Option::None;
        self.needs_backup = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.model.clear();
        self.fw_major = ::std::option::Option::None;
        self.fw_minor = ::std::option::Option::None;
        self.fw_patch = ::std::option::Option::None;
        self.fw_vendor.clear();
        self.fw_vendor_keys.clear();
        self.unfinished_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.recovery_mode = ::std::option::Option::None;
        self.capabilities.clear();
        self.backup_type = ::std::option::Option::None;
        self.sd_card_present = ::std::option::Option::None;
        self.sd_protection = ::std::option::Option::None;
        self.wipe_code_protection = ::std::option::Option::None;
        self.session_id.clear();
        self.passphrase_always_on_device = ::std::option::Option::None;
        self.safety_checks = ::std::option::Option::None;
        self.auto_lock_delay_ms = ::std::option::Option::None;
        self.display_rotation = ::std::option::Option::None;
        self.experimental_features = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Features_Capability {
    Capability_Bitcoin = 1,
    Capability_Bitcoin_like = 2,
    Capability_Binance = 3,
    Capability_Cardano = 4,
    Capability_Crypto = 5,
    Capability_EOS = 6,
    Capability_Ethereum = 7,
    Capability_Lisk = 8,
    Capability_Monero = 9,
    Capability_NEM = 10,
    Capability_Ripple = 11,
    Capability_Stellar = 12,
    Capability_Tezos = 13,
    Capability_U2F = 14,
    Capability_Shamir = 15,
    Capability_ShamirGroups = 16,
    Capability_PassphraseEntry = 17,
}

impl ::protobuf::ProtobufEnum for Features_Capability {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Features_Capability> {
        match value {
            1 => ::std::option::Option::Some(Features_Capability::Capability_Bitcoin),
            2 => ::std::option::Option::Some(Features_Capability::Capability_Bitcoin_like),
            3 => ::std::option::Option::Some(Features_Capability::Capability_Binance),
            4 => ::std::option::Option::Some(Features_Capability::Capability_Cardano),
            5 => ::std::option::Option::Some(Features_Capability::Capability_Crypto),
            6 => ::std::option::Option::Some(Features_Capability::Capability_EOS),
            7 => ::std::option::Option::Some(Features_Capability::Capability_Ethereum),
            8 => ::std::option::Option::Some(Features_Capability::Capability_Lisk),
            9 => ::std::option::Option::Some(Features_Capability::Capability_Monero),
            10 => ::std::option::Option::Some(Features_Capability::Capability_NEM),
            11 => ::std::option::Option::Some(Features_Capability::Capability_Ripple),
            12 => ::std::option::Option::Some(Features_Capability::Capability_Stellar),
            13 => ::std::option::Option::Some(Features_Capability::Capability_Tezos),
            14 => ::std::option::Option::Some(Features_Capability::Capability_U2F),
            15 => ::std::option::Option::Some(Features_Capability::Capability_Shamir),
            16 => ::std::option::Option::Some(Features_Capability::Capability_ShamirGroups),
            17 => ::std::option::Option::Some(Features_Capability::Capability_PassphraseEntry),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Features_Capability] = &[
            Features_Capability::Capability_Bitcoin,
            Features_Capability::Capability_Bitcoin_like,
            Features_Capability::Capability_Binance,
            Features_Capability::Capability_Cardano,
            Features_Capability::Capability_Crypto,
            Features_Capability::Capability_EOS,
            Features_Capability::Capability_Ethereum,
            Features_Capability::Capability_Lisk,
            Features_Capability::Capability_Monero,
            Features_Capability::Capability_NEM,
            Features_Capability::Capability_Ripple,
            Features_Capability::Capability_Stellar,
            Features_Capability::Capability_Tezos,
            Features_Capability::Capability_U2F,
            Features_Capability::Capability_Shamir,
            Features_Capability::Capability_ShamirGroups,
            Features_Capability::Capability_PassphraseEntry,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Features_Capability>("Features.Capability", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Features_Capability {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Features_Capability {
    fn default() -> Self {
        Features_Capability::Capability_Bitcoin
    }
}

impl ::protobuf::reflect::ProtobufValue for Features_Capability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockDevice {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockDevice {
    fn default() -> &'a LockDevice {
        <LockDevice as ::protobuf::Message>::default_instance()
    }
}

impl LockDevice {
    pub fn new() -> LockDevice {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LockDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockDevice {
        LockDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockDevice>(
                "LockDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockDevice {
        static instance: ::protobuf::rt::LazyV2<LockDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockDevice::new)
    }
}

impl ::protobuf::Clear for LockDevice {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndSession {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndSession {
    fn default() -> &'a EndSession {
        <EndSession as ::protobuf::Message>::default_instance()
    }
}

impl EndSession {
    pub fn new() -> EndSession {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EndSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndSession {
        EndSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndSession>(
                "EndSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndSession {
        static instance: ::protobuf::rt::LazyV2<EndSession> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndSession::new)
    }
}

impl ::protobuf::Clear for EndSession {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndSession {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplySettings {
    // message fields
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    use_passphrase: ::std::option::Option<bool>,
    homescreen: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    auto_lock_delay_ms: ::std::option::Option<u32>,
    display_rotation: ::std::option::Option<u32>,
    passphrase_always_on_device: ::std::option::Option<bool>,
    safety_checks: ::std::option::Option<SafetyCheckLevel>,
    experimental_features: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplySettings {
    fn default() -> &'a ApplySettings {
        <ApplySettings as ::protobuf::Message>::default_instance()
    }
}

impl ApplySettings {
    pub fn new() -> ApplySettings {
        ::std::default::Default::default()
    }

    // optional string language = 1;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 2;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool use_passphrase = 3;


    pub fn get_use_passphrase(&self) -> bool {
        self.use_passphrase.unwrap_or(false)
    }
    pub fn clear_use_passphrase(&mut self) {
        self.use_passphrase = ::std::option::Option::None;
    }

    pub fn has_use_passphrase(&self) -> bool {
        self.use_passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_passphrase(&mut self, v: bool) {
        self.use_passphrase = ::std::option::Option::Some(v);
    }

    // optional bytes homescreen = 4;


    pub fn get_homescreen(&self) -> &[u8] {
        match self.homescreen.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_homescreen(&mut self) {
        self.homescreen.clear();
    }

    pub fn has_homescreen(&self) -> bool {
        self.homescreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen(&mut self, v: ::std::vec::Vec<u8>) {
        self.homescreen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_homescreen(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.homescreen.is_none() {
            self.homescreen.set_default();
        }
        self.homescreen.as_mut().unwrap()
    }

    // Take field
    pub fn take_homescreen(&mut self) -> ::std::vec::Vec<u8> {
        self.homescreen.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 auto_lock_delay_ms = 6;


    pub fn get_auto_lock_delay_ms(&self) -> u32 {
        self.auto_lock_delay_ms.unwrap_or(0)
    }
    pub fn clear_auto_lock_delay_ms(&mut self) {
        self.auto_lock_delay_ms = ::std::option::Option::None;
    }

    pub fn has_auto_lock_delay_ms(&self) -> bool {
        self.auto_lock_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_lock_delay_ms(&mut self, v: u32) {
        self.auto_lock_delay_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 display_rotation = 7;


    pub fn get_display_rotation(&self) -> u32 {
        self.display_rotation.unwrap_or(0)
    }
    pub fn clear_display_rotation(&mut self) {
        self.display_rotation = ::std::option::Option::None;
    }

    pub fn has_display_rotation(&self) -> bool {
        self.display_rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rotation(&mut self, v: u32) {
        self.display_rotation = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_always_on_device = 8;


    pub fn get_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.unwrap_or(false)
    }
    pub fn clear_passphrase_always_on_device(&mut self) {
        self.passphrase_always_on_device = ::std::option::Option::None;
    }

    pub fn has_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_always_on_device(&mut self, v: bool) {
        self.passphrase_always_on_device = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;


    pub fn get_safety_checks(&self) -> SafetyCheckLevel {
        self.safety_checks.unwrap_or(SafetyCheckLevel::Strict)
    }
    pub fn clear_safety_checks(&mut self) {
        self.safety_checks = ::std::option::Option::None;
    }

    pub fn has_safety_checks(&self) -> bool {
        self.safety_checks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_safety_checks(&mut self, v: SafetyCheckLevel) {
        self.safety_checks = ::std::option::Option::Some(v);
    }

    // optional bool experimental_features = 10;


    pub fn get_experimental_features(&self) -> bool {
        self.experimental_features.unwrap_or(false)
    }
    pub fn clear_experimental_features(&mut self) {
        self.experimental_features = ::std::option::Option::None;
    }

    pub fn has_experimental_features(&self) -> bool {
        self.experimental_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_features(&mut self, v: bool) {
        self.experimental_features = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ApplySettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_passphrase = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.homescreen)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auto_lock_delay_ms = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.display_rotation = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_always_on_device = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.safety_checks, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.experimental_features = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.use_passphrase {
            my_size += 2;
        }
        if let Some(ref v) = self.homescreen.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.auto_lock_delay_ms {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_rotation {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passphrase_always_on_device {
            my_size += 2;
        }
        if let Some(v) = self.safety_checks {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        if let Some(v) = self.experimental_features {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.use_passphrase {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.homescreen.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.auto_lock_delay_ms {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.display_rotation {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.passphrase_always_on_device {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.safety_checks {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.experimental_features {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplySettings {
        ApplySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &ApplySettings| { &m.language },
                |m: &mut ApplySettings| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &ApplySettings| { &m.label },
                |m: &mut ApplySettings| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_passphrase",
                |m: &ApplySettings| { &m.use_passphrase },
                |m: &mut ApplySettings| { &mut m.use_passphrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "homescreen",
                |m: &ApplySettings| { &m.homescreen },
                |m: &mut ApplySettings| { &mut m.homescreen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "auto_lock_delay_ms",
                |m: &ApplySettings| { &m.auto_lock_delay_ms },
                |m: &mut ApplySettings| { &mut m.auto_lock_delay_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "display_rotation",
                |m: &ApplySettings| { &m.display_rotation },
                |m: &mut ApplySettings| { &mut m.display_rotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_always_on_device",
                |m: &ApplySettings| { &m.passphrase_always_on_device },
                |m: &mut ApplySettings| { &mut m.passphrase_always_on_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafetyCheckLevel>>(
                "safety_checks",
                |m: &ApplySettings| { &m.safety_checks },
                |m: &mut ApplySettings| { &mut m.safety_checks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "experimental_features",
                |m: &ApplySettings| { &m.experimental_features },
                |m: &mut ApplySettings| { &mut m.experimental_features },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplySettings>(
                "ApplySettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplySettings {
        static instance: ::protobuf::rt::LazyV2<ApplySettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplySettings::new)
    }
}

impl ::protobuf::Clear for ApplySettings {
    fn clear(&mut self) {
        self.language.clear();
        self.label.clear();
        self.use_passphrase = ::std::option::Option::None;
        self.homescreen.clear();
        self.auto_lock_delay_ms = ::std::option::Option::None;
        self.display_rotation = ::std::option::Option::None;
        self.passphrase_always_on_device = ::std::option::Option::None;
        self.safety_checks = ::std::option::Option::None;
        self.experimental_features = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplyFlags {
    // message fields
    flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplyFlags {
    fn default() -> &'a ApplyFlags {
        <ApplyFlags as ::protobuf::Message>::default_instance()
    }
}

impl ApplyFlags {
    pub fn new() -> ApplyFlags {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ApplyFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplyFlags {
        ApplyFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &ApplyFlags| { &m.flags },
                |m: &mut ApplyFlags| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplyFlags>(
                "ApplyFlags",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplyFlags {
        static instance: ::protobuf::rt::LazyV2<ApplyFlags> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplyFlags::new)
    }
}

impl ::protobuf::Clear for ApplyFlags {
    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplyFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePin {
    // message fields
    remove: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangePin {
    fn default() -> &'a ChangePin {
        <ChangePin as ::protobuf::Message>::default_instance()
    }
}

impl ChangePin {
    pub fn new() -> ChangePin {
        ::std::default::Default::default()
    }

    // optional bool remove = 1;


    pub fn get_remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }
    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChangePin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.remove {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.remove {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePin {
        ChangePin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remove",
                |m: &ChangePin| { &m.remove },
                |m: &mut ChangePin| { &mut m.remove },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangePin>(
                "ChangePin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangePin {
        static instance: ::protobuf::rt::LazyV2<ChangePin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangePin::new)
    }
}

impl ::protobuf::Clear for ChangePin {
    fn clear(&mut self) {
        self.remove = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeWipeCode {
    // message fields
    remove: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeWipeCode {
    fn default() -> &'a ChangeWipeCode {
        <ChangeWipeCode as ::protobuf::Message>::default_instance()
    }
}

impl ChangeWipeCode {
    pub fn new() -> ChangeWipeCode {
        ::std::default::Default::default()
    }

    // optional bool remove = 1;


    pub fn get_remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }
    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChangeWipeCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.remove {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.remove {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeWipeCode {
        ChangeWipeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remove",
                |m: &ChangeWipeCode| { &m.remove },
                |m: &mut ChangeWipeCode| { &mut m.remove },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeWipeCode>(
                "ChangeWipeCode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangeWipeCode {
        static instance: ::protobuf::rt::LazyV2<ChangeWipeCode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangeWipeCode::new)
    }
}

impl ::protobuf::Clear for ChangeWipeCode {
    fn clear(&mut self) {
        self.remove = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeWipeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeWipeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SdProtect {
    // message fields
    operation: ::std::option::Option<SdProtect_SdProtectOperationType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SdProtect {
    fn default() -> &'a SdProtect {
        <SdProtect as ::protobuf::Message>::default_instance()
    }
}

impl SdProtect {
    pub fn new() -> SdProtect {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;


    pub fn get_operation(&self) -> SdProtect_SdProtectOperationType {
        self.operation.unwrap_or(SdProtect_SdProtectOperationType::DISABLE)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: SdProtect_SdProtectOperationType) {
        self.operation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SdProtect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SdProtect {
        SdProtect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SdProtect_SdProtectOperationType>>(
                "operation",
                |m: &SdProtect| { &m.operation },
                |m: &mut SdProtect| { &mut m.operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SdProtect>(
                "SdProtect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SdProtect {
        static instance: ::protobuf::rt::LazyV2<SdProtect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SdProtect::new)
    }
}

impl ::protobuf::Clear for SdProtect {
    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SdProtect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SdProtect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SdProtect_SdProtectOperationType {
    DISABLE = 0,
    ENABLE = 1,
    REFRESH = 2,
}

impl ::protobuf::ProtobufEnum for SdProtect_SdProtectOperationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SdProtect_SdProtectOperationType> {
        match value {
            0 => ::std::option::Option::Some(SdProtect_SdProtectOperationType::DISABLE),
            1 => ::std::option::Option::Some(SdProtect_SdProtectOperationType::ENABLE),
            2 => ::std::option::Option::Some(SdProtect_SdProtectOperationType::REFRESH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SdProtect_SdProtectOperationType] = &[
            SdProtect_SdProtectOperationType::DISABLE,
            SdProtect_SdProtectOperationType::ENABLE,
            SdProtect_SdProtectOperationType::REFRESH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SdProtect_SdProtectOperationType>("SdProtect.SdProtectOperationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SdProtect_SdProtectOperationType {
}

impl ::std::default::Default for SdProtect_SdProtectOperationType {
    fn default() -> Self {
        SdProtect_SdProtectOperationType::DISABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for SdProtect_SdProtectOperationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    button_protection: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // optional string message = 1;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool button_protection = 2;


    pub fn get_button_protection(&self) -> bool {
        self.button_protection.unwrap_or(false)
    }
    pub fn clear_button_protection(&mut self) {
        self.button_protection = ::std::option::Option::None;
    }

    pub fn has_button_protection(&self) -> bool {
        self.button_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_protection(&mut self, v: bool) {
        self.button_protection = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.button_protection = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.button_protection {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.button_protection {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Ping| { &m.message },
                |m: &mut Ping| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "button_protection",
                |m: &Ping| { &m.button_protection },
                |m: &mut Ping| { &mut m.button_protection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.message.clear();
        self.button_protection = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cancel {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cancel {
    fn default() -> &'a Cancel {
        <Cancel as ::protobuf::Message>::default_instance()
    }
}

impl Cancel {
    pub fn new() -> Cancel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Cancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cancel {
        Cancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cancel>(
                "Cancel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cancel {
        static instance: ::protobuf::rt::LazyV2<Cancel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cancel::new)
    }
}

impl ::protobuf::Clear for Cancel {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cancel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEntropy {
    // message fields
    size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEntropy {
    fn default() -> &'a GetEntropy {
        <GetEntropy as ::protobuf::Message>::default_instance()
    }
}

impl GetEntropy {
    pub fn new() -> GetEntropy {
        ::std::default::Default::default()
    }

    // required uint32 size = 1;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetEntropy {
    fn is_initialized(&self) -> bool {
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.size {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEntropy {
        GetEntropy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &GetEntropy| { &m.size },
                |m: &mut GetEntropy| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEntropy>(
                "GetEntropy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEntropy {
        static instance: ::protobuf::rt::LazyV2<GetEntropy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEntropy::new)
    }
}

impl ::protobuf::Clear for GetEntropy {
    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEntropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEntropy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entropy {
    // message fields
    entropy: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Entropy {
    fn default() -> &'a Entropy {
        <Entropy as ::protobuf::Message>::default_instance()
    }
}

impl Entropy {
    pub fn new() -> Entropy {
        ::std::default::Default::default()
    }

    // required bytes entropy = 1;


    pub fn get_entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_entropy(&mut self) {
        self.entropy.clear();
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy.set_default();
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Entropy {
    fn is_initialized(&self) -> bool {
        if self.entropy.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entropy.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entropy {
        Entropy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "entropy",
                |m: &Entropy| { &m.entropy },
                |m: &mut Entropy| { &mut m.entropy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Entropy>(
                "Entropy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Entropy {
        static instance: ::protobuf::rt::LazyV2<Entropy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Entropy::new)
    }
}

impl ::protobuf::Clear for Entropy {
    fn clear(&mut self) {
        self.entropy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entropy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WipeDevice {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WipeDevice {
    fn default() -> &'a WipeDevice {
        <WipeDevice as ::protobuf::Message>::default_instance()
    }
}

impl WipeDevice {
    pub fn new() -> WipeDevice {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WipeDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WipeDevice {
        WipeDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WipeDevice>(
                "WipeDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WipeDevice {
        static instance: ::protobuf::rt::LazyV2<WipeDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WipeDevice::new)
    }
}

impl ::protobuf::Clear for WipeDevice {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WipeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WipeDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadDevice {
    // message fields
    pub mnemonics: ::protobuf::RepeatedField<::std::string::String>,
    pin: ::protobuf::SingularField<::std::string::String>,
    passphrase_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    skip_checksum: ::std::option::Option<bool>,
    u2f_counter: ::std::option::Option<u32>,
    needs_backup: ::std::option::Option<bool>,
    no_backup: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadDevice {
    fn default() -> &'a LoadDevice {
        <LoadDevice as ::protobuf::Message>::default_instance()
    }
}

impl LoadDevice {
    pub fn new() -> LoadDevice {
        ::std::default::Default::default()
    }

    // repeated string mnemonics = 1;


    pub fn get_mnemonics(&self) -> &[::std::string::String] {
        &self.mnemonics
    }
    pub fn clear_mnemonics(&mut self) {
        self.mnemonics.clear();
    }

    // Param is passed by value, moved
    pub fn set_mnemonics(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mnemonics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mnemonics(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mnemonics
    }

    // Take field
    pub fn take_mnemonics(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mnemonics, ::protobuf::RepeatedField::new())
    }

    // optional string pin = 3;


    pub fn get_pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool passphrase_protection = 4;


    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }
    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 5;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "en-US",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 6;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool skip_checksum = 7;


    pub fn get_skip_checksum(&self) -> bool {
        self.skip_checksum.unwrap_or(false)
    }
    pub fn clear_skip_checksum(&mut self) {
        self.skip_checksum = ::std::option::Option::None;
    }

    pub fn has_skip_checksum(&self) -> bool {
        self.skip_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_checksum(&mut self, v: bool) {
        self.skip_checksum = ::std::option::Option::Some(v);
    }

    // optional uint32 u2f_counter = 8;


    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional bool needs_backup = 9;


    pub fn get_needs_backup(&self) -> bool {
        self.needs_backup.unwrap_or(false)
    }
    pub fn clear_needs_backup(&mut self) {
        self.needs_backup = ::std::option::Option::None;
    }

    pub fn has_needs_backup(&self) -> bool {
        self.needs_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_backup(&mut self, v: bool) {
        self.needs_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 10;


    pub fn get_no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }
    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LoadDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mnemonics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pin)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_checksum = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_backup = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_backup = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mnemonics {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.skip_checksum {
            my_size += 2;
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.needs_backup {
            my_size += 2;
        }
        if let Some(v) = self.no_backup {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mnemonics {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.pin.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.skip_checksum {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.needs_backup {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadDevice {
        LoadDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mnemonics",
                |m: &LoadDevice| { &m.mnemonics },
                |m: &mut LoadDevice| { &mut m.mnemonics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pin",
                |m: &LoadDevice| { &m.pin },
                |m: &mut LoadDevice| { &mut m.pin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_protection",
                |m: &LoadDevice| { &m.passphrase_protection },
                |m: &mut LoadDevice| { &mut m.passphrase_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &LoadDevice| { &m.language },
                |m: &mut LoadDevice| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &LoadDevice| { &m.label },
                |m: &mut LoadDevice| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skip_checksum",
                |m: &LoadDevice| { &m.skip_checksum },
                |m: &mut LoadDevice| { &mut m.skip_checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u2f_counter",
                |m: &LoadDevice| { &m.u2f_counter },
                |m: &mut LoadDevice| { &mut m.u2f_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_backup",
                |m: &LoadDevice| { &m.needs_backup },
                |m: &mut LoadDevice| { &mut m.needs_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_backup",
                |m: &LoadDevice| { &m.no_backup },
                |m: &mut LoadDevice| { &mut m.no_backup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadDevice>(
                "LoadDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadDevice {
        static instance: ::protobuf::rt::LazyV2<LoadDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadDevice::new)
    }
}

impl ::protobuf::Clear for LoadDevice {
    fn clear(&mut self) {
        self.mnemonics.clear();
        self.pin.clear();
        self.passphrase_protection = ::std::option::Option::None;
        self.language.clear();
        self.label.clear();
        self.skip_checksum = ::std::option::Option::None;
        self.u2f_counter = ::std::option::Option::None;
        self.needs_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetDevice {
    // message fields
    display_random: ::std::option::Option<bool>,
    strength: ::std::option::Option<u32>,
    passphrase_protection: ::std::option::Option<bool>,
    pin_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    u2f_counter: ::std::option::Option<u32>,
    skip_backup: ::std::option::Option<bool>,
    no_backup: ::std::option::Option<bool>,
    backup_type: ::std::option::Option<BackupType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetDevice {
    fn default() -> &'a ResetDevice {
        <ResetDevice as ::protobuf::Message>::default_instance()
    }
}

impl ResetDevice {
    pub fn new() -> ResetDevice {
        ::std::default::Default::default()
    }

    // optional bool display_random = 1;


    pub fn get_display_random(&self) -> bool {
        self.display_random.unwrap_or(false)
    }
    pub fn clear_display_random(&mut self) {
        self.display_random = ::std::option::Option::None;
    }

    pub fn has_display_random(&self) -> bool {
        self.display_random.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_random(&mut self, v: bool) {
        self.display_random = ::std::option::Option::Some(v);
    }

    // optional uint32 strength = 2;


    pub fn get_strength(&self) -> u32 {
        self.strength.unwrap_or(256u32)
    }
    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: u32) {
        self.strength = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 3;


    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }
    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional bool pin_protection = 4;


    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }
    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 5;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "en-US",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 6;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 u2f_counter = 7;


    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional bool skip_backup = 8;


    pub fn get_skip_backup(&self) -> bool {
        self.skip_backup.unwrap_or(false)
    }
    pub fn clear_skip_backup(&mut self) {
        self.skip_backup = ::std::option::Option::None;
    }

    pub fn has_skip_backup(&self) -> bool {
        self.skip_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_backup(&mut self, v: bool) {
        self.skip_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 9;


    pub fn get_no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }
    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.BackupType backup_type = 10;


    pub fn get_backup_type(&self) -> BackupType {
        self.backup_type.unwrap_or(BackupType::Bip39)
    }
    pub fn clear_backup_type(&mut self) {
        self.backup_type = ::std::option::Option::None;
    }

    pub fn has_backup_type(&self) -> bool {
        self.backup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup_type(&mut self, v: BackupType) {
        self.backup_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ResetDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.display_random = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_backup = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_backup = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.backup_type, 10, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_random {
            my_size += 2;
        }
        if let Some(v) = self.strength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skip_backup {
            my_size += 2;
        }
        if let Some(v) = self.no_backup {
            my_size += 2;
        }
        if let Some(v) = self.backup_type {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_random {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.strength {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.skip_backup {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.backup_type {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetDevice {
        ResetDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "display_random",
                |m: &ResetDevice| { &m.display_random },
                |m: &mut ResetDevice| { &mut m.display_random },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "strength",
                |m: &ResetDevice| { &m.strength },
                |m: &mut ResetDevice| { &mut m.strength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_protection",
                |m: &ResetDevice| { &m.passphrase_protection },
                |m: &mut ResetDevice| { &mut m.passphrase_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pin_protection",
                |m: &ResetDevice| { &m.pin_protection },
                |m: &mut ResetDevice| { &mut m.pin_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &ResetDevice| { &m.language },
                |m: &mut ResetDevice| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &ResetDevice| { &m.label },
                |m: &mut ResetDevice| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u2f_counter",
                |m: &ResetDevice| { &m.u2f_counter },
                |m: &mut ResetDevice| { &mut m.u2f_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skip_backup",
                |m: &ResetDevice| { &m.skip_backup },
                |m: &mut ResetDevice| { &mut m.skip_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_backup",
                |m: &ResetDevice| { &m.no_backup },
                |m: &mut ResetDevice| { &mut m.no_backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BackupType>>(
                "backup_type",
                |m: &ResetDevice| { &m.backup_type },
                |m: &mut ResetDevice| { &mut m.backup_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResetDevice>(
                "ResetDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResetDevice {
        static instance: ::protobuf::rt::LazyV2<ResetDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetDevice::new)
    }
}

impl ::protobuf::Clear for ResetDevice {
    fn clear(&mut self) {
        self.display_random = ::std::option::Option::None;
        self.strength = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.pin_protection = ::std::option::Option::None;
        self.language.clear();
        self.label.clear();
        self.u2f_counter = ::std::option::Option::None;
        self.skip_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.backup_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupDevice {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupDevice {
    fn default() -> &'a BackupDevice {
        <BackupDevice as ::protobuf::Message>::default_instance()
    }
}

impl BackupDevice {
    pub fn new() -> BackupDevice {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackupDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupDevice {
        BackupDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupDevice>(
                "BackupDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupDevice {
        static instance: ::protobuf::rt::LazyV2<BackupDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupDevice::new)
    }
}

impl ::protobuf::Clear for BackupDevice {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntropyRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntropyRequest {
    fn default() -> &'a EntropyRequest {
        <EntropyRequest as ::protobuf::Message>::default_instance()
    }
}

impl EntropyRequest {
    pub fn new() -> EntropyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EntropyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntropyRequest {
        EntropyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntropyRequest>(
                "EntropyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntropyRequest {
        static instance: ::protobuf::rt::LazyV2<EntropyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntropyRequest::new)
    }
}

impl ::protobuf::Clear for EntropyRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntropyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntropyAck {
    // message fields
    entropy: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntropyAck {
    fn default() -> &'a EntropyAck {
        <EntropyAck as ::protobuf::Message>::default_instance()
    }
}

impl EntropyAck {
    pub fn new() -> EntropyAck {
        ::std::default::Default::default()
    }

    // optional bytes entropy = 1;


    pub fn get_entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_entropy(&mut self) {
        self.entropy.clear();
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy.set_default();
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EntropyAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entropy.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntropyAck {
        EntropyAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "entropy",
                |m: &EntropyAck| { &m.entropy },
                |m: &mut EntropyAck| { &mut m.entropy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntropyAck>(
                "EntropyAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntropyAck {
        static instance: ::protobuf::rt::LazyV2<EntropyAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntropyAck::new)
    }
}

impl ::protobuf::Clear for EntropyAck {
    fn clear(&mut self) {
        self.entropy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntropyAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoveryDevice {
    // message fields
    word_count: ::std::option::Option<u32>,
    passphrase_protection: ::std::option::Option<bool>,
    pin_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    enforce_wordlist: ::std::option::Option<bool>,
    field_type: ::std::option::Option<RecoveryDevice_RecoveryDeviceType>,
    u2f_counter: ::std::option::Option<u32>,
    dry_run: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoveryDevice {
    fn default() -> &'a RecoveryDevice {
        <RecoveryDevice as ::protobuf::Message>::default_instance()
    }
}

impl RecoveryDevice {
    pub fn new() -> RecoveryDevice {
        ::std::default::Default::default()
    }

    // optional uint32 word_count = 1;


    pub fn get_word_count(&self) -> u32 {
        self.word_count.unwrap_or(0)
    }
    pub fn clear_word_count(&mut self) {
        self.word_count = ::std::option::Option::None;
    }

    pub fn has_word_count(&self) -> bool {
        self.word_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_count(&mut self, v: u32) {
        self.word_count = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 2;


    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }
    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional bool pin_protection = 3;


    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }
    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 4;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 5;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enforce_wordlist = 6;


    pub fn get_enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.unwrap_or(false)
    }
    pub fn clear_enforce_wordlist(&mut self) {
        self.enforce_wordlist = ::std::option::Option::None;
    }

    pub fn has_enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enforce_wordlist(&mut self, v: bool) {
        self.enforce_wordlist = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;


    pub fn get_field_type(&self) -> RecoveryDevice_RecoveryDeviceType {
        self.field_type.unwrap_or(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: RecoveryDevice_RecoveryDeviceType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 u2f_counter = 9;


    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional bool dry_run = 10;


    pub fn get_dry_run(&self) -> bool {
        self.dry_run.unwrap_or(false)
    }
    pub fn clear_dry_run(&mut self) {
        self.dry_run = ::std::option::Option::None;
    }

    pub fn has_dry_run(&self) -> bool {
        self.dry_run.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dry_run(&mut self, v: bool) {
        self.dry_run = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RecoveryDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.word_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enforce_wordlist = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dry_run = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.word_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.enforce_wordlist {
            my_size += 2;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dry_run {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.word_count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.enforce_wordlist {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.dry_run {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoveryDevice {
        RecoveryDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "word_count",
                |m: &RecoveryDevice| { &m.word_count },
                |m: &mut RecoveryDevice| { &mut m.word_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphrase_protection",
                |m: &RecoveryDevice| { &m.passphrase_protection },
                |m: &mut RecoveryDevice| { &mut m.passphrase_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pin_protection",
                |m: &RecoveryDevice| { &m.pin_protection },
                |m: &mut RecoveryDevice| { &mut m.pin_protection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &RecoveryDevice| { &m.language },
                |m: &mut RecoveryDevice| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &RecoveryDevice| { &m.label },
                |m: &mut RecoveryDevice| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enforce_wordlist",
                |m: &RecoveryDevice| { &m.enforce_wordlist },
                |m: &mut RecoveryDevice| { &mut m.enforce_wordlist },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RecoveryDevice_RecoveryDeviceType>>(
                "type",
                |m: &RecoveryDevice| { &m.field_type },
                |m: &mut RecoveryDevice| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u2f_counter",
                |m: &RecoveryDevice| { &m.u2f_counter },
                |m: &mut RecoveryDevice| { &mut m.u2f_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dry_run",
                |m: &RecoveryDevice| { &m.dry_run },
                |m: &mut RecoveryDevice| { &mut m.dry_run },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecoveryDevice>(
                "RecoveryDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecoveryDevice {
        static instance: ::protobuf::rt::LazyV2<RecoveryDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecoveryDevice::new)
    }
}

impl ::protobuf::Clear for RecoveryDevice {
    fn clear(&mut self) {
        self.word_count = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.pin_protection = ::std::option::Option::None;
        self.language.clear();
        self.label.clear();
        self.enforce_wordlist = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.u2f_counter = ::std::option::Option::None;
        self.dry_run = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoveryDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveryDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RecoveryDevice_RecoveryDeviceType {
    RecoveryDeviceType_ScrambledWords = 0,
    RecoveryDeviceType_Matrix = 1,
}

impl ::protobuf::ProtobufEnum for RecoveryDevice_RecoveryDeviceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecoveryDevice_RecoveryDeviceType> {
        match value {
            0 => ::std::option::Option::Some(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords),
            1 => ::std::option::Option::Some(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_Matrix),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RecoveryDevice_RecoveryDeviceType] = &[
            RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords,
            RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_Matrix,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RecoveryDevice_RecoveryDeviceType>("RecoveryDevice.RecoveryDeviceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RecoveryDevice_RecoveryDeviceType {
}

impl ::std::default::Default for RecoveryDevice_RecoveryDeviceType {
    fn default() -> Self {
        RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveryDevice_RecoveryDeviceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WordRequest {
    // message fields
    field_type: ::std::option::Option<WordRequest_WordRequestType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WordRequest {
    fn default() -> &'a WordRequest {
        <WordRequest as ::protobuf::Message>::default_instance()
    }
}

impl WordRequest {
    pub fn new() -> WordRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;


    pub fn get_field_type(&self) -> WordRequest_WordRequestType {
        self.field_type.unwrap_or(WordRequest_WordRequestType::WordRequestType_Plain)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: WordRequest_WordRequestType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WordRequest {
        WordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WordRequest_WordRequestType>>(
                "type",
                |m: &WordRequest| { &m.field_type },
                |m: &mut WordRequest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WordRequest>(
                "WordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WordRequest {
        static instance: ::protobuf::rt::LazyV2<WordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WordRequest::new)
    }
}

impl ::protobuf::Clear for WordRequest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WordRequest_WordRequestType {
    WordRequestType_Plain = 0,
    WordRequestType_Matrix9 = 1,
    WordRequestType_Matrix6 = 2,
}

impl ::protobuf::ProtobufEnum for WordRequest_WordRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WordRequest_WordRequestType> {
        match value {
            0 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Plain),
            1 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Matrix9),
            2 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Matrix6),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WordRequest_WordRequestType] = &[
            WordRequest_WordRequestType::WordRequestType_Plain,
            WordRequest_WordRequestType::WordRequestType_Matrix9,
            WordRequest_WordRequestType::WordRequestType_Matrix6,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WordRequest_WordRequestType>("WordRequest.WordRequestType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WordRequest_WordRequestType {
}

impl ::std::default::Default for WordRequest_WordRequestType {
    fn default() -> Self {
        WordRequest_WordRequestType::WordRequestType_Plain
    }
}

impl ::protobuf::reflect::ProtobufValue for WordRequest_WordRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WordAck {
    // message fields
    word: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WordAck {
    fn default() -> &'a WordAck {
        <WordAck as ::protobuf::Message>::default_instance()
    }
}

impl WordAck {
    pub fn new() -> WordAck {
        ::std::default::Default::default()
    }

    // required string word = 1;


    pub fn get_word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_word(&mut self) {
        self.word.clear();
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word.set_default();
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for WordAck {
    fn is_initialized(&self) -> bool {
        if self.word.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.word)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.word.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WordAck {
        WordAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "word",
                |m: &WordAck| { &m.word },
                |m: &mut WordAck| { &mut m.word },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WordAck>(
                "WordAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WordAck {
        static instance: ::protobuf::rt::LazyV2<WordAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WordAck::new)
    }
}

impl ::protobuf::Clear for WordAck {
    fn clear(&mut self) {
        self.word.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WordAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetU2FCounter {
    // message fields
    u2f_counter: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetU2FCounter {
    fn default() -> &'a SetU2FCounter {
        <SetU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl SetU2FCounter {
    pub fn new() -> SetU2FCounter {
        ::std::default::Default::default()
    }

    // optional uint32 u2f_counter = 1;


    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetU2FCounter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.u2f_counter {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetU2FCounter {
        SetU2FCounter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u2f_counter",
                |m: &SetU2FCounter| { &m.u2f_counter },
                |m: &mut SetU2FCounter| { &mut m.u2f_counter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetU2FCounter>(
                "SetU2FCounter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetU2FCounter {
        static instance: ::protobuf::rt::LazyV2<SetU2FCounter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetU2FCounter::new)
    }
}

impl ::protobuf::Clear for SetU2FCounter {
    fn clear(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetU2FCounter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNextU2FCounter {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNextU2FCounter {
    fn default() -> &'a GetNextU2FCounter {
        <GetNextU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl GetNextU2FCounter {
    pub fn new() -> GetNextU2FCounter {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetNextU2FCounter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNextU2FCounter {
        GetNextU2FCounter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNextU2FCounter>(
                "GetNextU2FCounter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNextU2FCounter {
        static instance: ::protobuf::rt::LazyV2<GetNextU2FCounter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNextU2FCounter::new)
    }
}

impl ::protobuf::Clear for GetNextU2FCounter {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNextU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNextU2FCounter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextU2FCounter {
    // message fields
    u2f_counter: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextU2FCounter {
    fn default() -> &'a NextU2FCounter {
        <NextU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl NextU2FCounter {
    pub fn new() -> NextU2FCounter {
        ::std::default::Default::default()
    }

    // optional uint32 u2f_counter = 1;


    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NextU2FCounter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.u2f_counter {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextU2FCounter {
        NextU2FCounter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u2f_counter",
                |m: &NextU2FCounter| { &m.u2f_counter },
                |m: &mut NextU2FCounter| { &mut m.u2f_counter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NextU2FCounter>(
                "NextU2FCounter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NextU2FCounter {
        static instance: ::protobuf::rt::LazyV2<NextU2FCounter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NextU2FCounter::new)
    }
}

impl ::protobuf::Clear for NextU2FCounter {
    fn clear(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextU2FCounter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoPreauthorized {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoPreauthorized {
    fn default() -> &'a DoPreauthorized {
        <DoPreauthorized as ::protobuf::Message>::default_instance()
    }
}

impl DoPreauthorized {
    pub fn new() -> DoPreauthorized {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DoPreauthorized {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoPreauthorized {
        DoPreauthorized::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoPreauthorized>(
                "DoPreauthorized",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoPreauthorized {
        static instance: ::protobuf::rt::LazyV2<DoPreauthorized> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoPreauthorized::new)
    }
}

impl ::protobuf::Clear for DoPreauthorized {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoPreauthorized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoPreauthorized {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreauthorizedRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreauthorizedRequest {
    fn default() -> &'a PreauthorizedRequest {
        <PreauthorizedRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreauthorizedRequest {
    pub fn new() -> PreauthorizedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreauthorizedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreauthorizedRequest {
        PreauthorizedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreauthorizedRequest>(
                "PreauthorizedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreauthorizedRequest {
        static instance: ::protobuf::rt::LazyV2<PreauthorizedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreauthorizedRequest::new)
    }
}

impl ::protobuf::Clear for PreauthorizedRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreauthorizedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreauthorizedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelAuthorization {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelAuthorization {
    fn default() -> &'a CancelAuthorization {
        <CancelAuthorization as ::protobuf::Message>::default_instance()
    }
}

impl CancelAuthorization {
    pub fn new() -> CancelAuthorization {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CancelAuthorization {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelAuthorization {
        CancelAuthorization::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CancelAuthorization>(
                "CancelAuthorization",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CancelAuthorization {
        static instance: ::protobuf::rt::LazyV2<CancelAuthorization> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CancelAuthorization::new)
    }
}

impl ::protobuf::Clear for CancelAuthorization {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelAuthorization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelAuthorization {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BackupType {
    Bip39 = 0,
    Slip39_Basic = 1,
    Slip39_Advanced = 2,
}

impl ::protobuf::ProtobufEnum for BackupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BackupType> {
        match value {
            0 => ::std::option::Option::Some(BackupType::Bip39),
            1 => ::std::option::Option::Some(BackupType::Slip39_Basic),
            2 => ::std::option::Option::Some(BackupType::Slip39_Advanced),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BackupType] = &[
            BackupType::Bip39,
            BackupType::Slip39_Basic,
            BackupType::Slip39_Advanced,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BackupType>("BackupType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BackupType {
}

impl ::std::default::Default for BackupType {
    fn default() -> Self {
        BackupType::Bip39
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafetyCheckLevel {
    Strict = 0,
    PromptAlways = 1,
    PromptTemporarily = 2,
}

impl ::protobuf::ProtobufEnum for SafetyCheckLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafetyCheckLevel> {
        match value {
            0 => ::std::option::Option::Some(SafetyCheckLevel::Strict),
            1 => ::std::option::Option::Some(SafetyCheckLevel::PromptAlways),
            2 => ::std::option::Option::Some(SafetyCheckLevel::PromptTemporarily),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SafetyCheckLevel] = &[
            SafetyCheckLevel::Strict,
            SafetyCheckLevel::PromptAlways,
            SafetyCheckLevel::PromptTemporarily,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SafetyCheckLevel>("SafetyCheckLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SafetyCheckLevel {
}

impl ::std::default::Default for SafetyCheckLevel {
    fn default() -> Self {
        SafetyCheckLevel::Strict
    }
}

impl ::protobuf::reflect::ProtobufValue for SafetyCheckLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19messages-management.proto\x12\x1dhw.trezor.messages.management\"+\
    \n\nInitialize\x12\x1d\n\nsession_id\x18\x01\x20\x01(\x0cR\tsessionId\"\
    \r\n\x0bGetFeatures\"\x8a\x0f\n\x08Features\x12\x16\n\x06vendor\x18\x01\
    \x20\x01(\tR\x06vendor\x12#\n\rmajor_version\x18\x02\x20\x01(\rR\x0cmajo\
    rVersion\x12#\n\rminor_version\x18\x03\x20\x01(\rR\x0cminorVersion\x12#\
    \n\rpatch_version\x18\x04\x20\x01(\rR\x0cpatchVersion\x12'\n\x0fbootload\
    er_mode\x18\x05\x20\x01(\x08R\x0ebootloaderMode\x12\x1b\n\tdevice_id\x18\
    \x06\x20\x01(\tR\x08deviceId\x12%\n\x0epin_protection\x18\x07\x20\x01(\
    \x08R\rpinProtection\x123\n\x15passphrase_protection\x18\x08\x20\x01(\
    \x08R\x14passphraseProtection\x12\x1a\n\x08language\x18\t\x20\x01(\tR\
    \x08language\x12\x14\n\x05label\x18\n\x20\x01(\tR\x05label\x12\x20\n\x0b\
    initialized\x18\x0c\x20\x01(\x08R\x0binitialized\x12\x1a\n\x08revision\
    \x18\r\x20\x01(\x0cR\x08revision\x12'\n\x0fbootloader_hash\x18\x0e\x20\
    \x01(\x0cR\x0ebootloaderHash\x12\x1a\n\x08imported\x18\x0f\x20\x01(\x08R\
    \x08imported\x12\x1a\n\x08unlocked\x18\x10\x20\x01(\x08R\x08unlocked\x12\
    )\n\x10firmware_present\x18\x12\x20\x01(\x08R\x0ffirmwarePresent\x12!\n\
    \x0cneeds_backup\x18\x13\x20\x01(\x08R\x0bneedsBackup\x12\x14\n\x05flags\
    \x18\x14\x20\x01(\rR\x05flags\x12\x14\n\x05model\x18\x15\x20\x01(\tR\x05\
    model\x12\x19\n\x08fw_major\x18\x16\x20\x01(\rR\x07fwMajor\x12\x19\n\x08\
    fw_minor\x18\x17\x20\x01(\rR\x07fwMinor\x12\x19\n\x08fw_patch\x18\x18\
    \x20\x01(\rR\x07fwPatch\x12\x1b\n\tfw_vendor\x18\x19\x20\x01(\tR\x08fwVe\
    ndor\x12$\n\x0efw_vendor_keys\x18\x1a\x20\x01(\x0cR\x0cfwVendorKeys\x12+\
    \n\x11unfinished_backup\x18\x1b\x20\x01(\x08R\x10unfinishedBackup\x12\
    \x1b\n\tno_backup\x18\x1c\x20\x01(\x08R\x08noBackup\x12#\n\rrecovery_mod\
    e\x18\x1d\x20\x01(\x08R\x0crecoveryMode\x12V\n\x0ccapabilities\x18\x1e\
    \x20\x03(\x0e22.hw.trezor.messages.management.Features.CapabilityR\x0cca\
    pabilities\x12J\n\x0bbackup_type\x18\x1f\x20\x01(\x0e2).hw.trezor.messag\
    es.management.BackupTypeR\nbackupType\x12&\n\x0fsd_card_present\x18\x20\
    \x20\x01(\x08R\rsdCardPresent\x12#\n\rsd_protection\x18!\x20\x01(\x08R\
    \x0csdProtection\x120\n\x14wipe_code_protection\x18\"\x20\x01(\x08R\x12w\
    ipeCodeProtection\x12\x1d\n\nsession_id\x18#\x20\x01(\x0cR\tsessionId\
    \x12=\n\x1bpassphrase_always_on_device\x18$\x20\x01(\x08R\x18passphraseA\
    lwaysOnDevice\x12T\n\rsafety_checks\x18%\x20\x01(\x0e2/.hw.trezor.messag\
    es.management.SafetyCheckLevelR\x0csafetyChecks\x12+\n\x12auto_lock_dela\
    y_ms\x18&\x20\x01(\rR\x0fautoLockDelayMs\x12)\n\x10display_rotation\x18'\
    \x20\x01(\rR\x0fdisplayRotation\x123\n\x15experimental_features\x18(\x20\
    \x01(\x08R\x14experimentalFeatures\"\xa2\x03\n\nCapability\x12\x16\n\x12\
    Capability_Bitcoin\x10\x01\x12\x1b\n\x17Capability_Bitcoin_like\x10\x02\
    \x12\x16\n\x12Capability_Binance\x10\x03\x12\x16\n\x12Capability_Cardano\
    \x10\x04\x12\x15\n\x11Capability_Crypto\x10\x05\x12\x12\n\x0eCapability_\
    EOS\x10\x06\x12\x17\n\x13Capability_Ethereum\x10\x07\x12\x13\n\x0fCapabi\
    lity_Lisk\x10\x08\x12\x15\n\x11Capability_Monero\x10\t\x12\x12\n\x0eCapa\
    bility_NEM\x10\n\x12\x15\n\x11Capability_Ripple\x10\x0b\x12\x16\n\x12Cap\
    ability_Stellar\x10\x0c\x12\x14\n\x10Capability_Tezos\x10\r\x12\x12\n\
    \x0eCapability_U2F\x10\x0e\x12\x15\n\x11Capability_Shamir\x10\x0f\x12\
    \x1b\n\x17Capability_ShamirGroups\x10\x10\x12\x1e\n\x1aCapability_Passph\
    raseEntry\x10\x11\"\x0c\n\nLockDevice\"\x0c\n\nEndSession\"\xaa\x03\n\rA\
    pplySettings\x12\x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\x12\
    \x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12%\n\x0euse_passphrase\
    \x18\x03\x20\x01(\x08R\rusePassphrase\x12\x1e\n\nhomescreen\x18\x04\x20\
    \x01(\x0cR\nhomescreen\x12+\n\x12auto_lock_delay_ms\x18\x06\x20\x01(\rR\
    \x0fautoLockDelayMs\x12)\n\x10display_rotation\x18\x07\x20\x01(\rR\x0fdi\
    splayRotation\x12=\n\x1bpassphrase_always_on_device\x18\x08\x20\x01(\x08\
    R\x18passphraseAlwaysOnDevice\x12T\n\rsafety_checks\x18\t\x20\x01(\x0e2/\
    .hw.trezor.messages.management.SafetyCheckLevelR\x0csafetyChecks\x123\n\
    \x15experimental_features\x18\n\x20\x01(\x08R\x14experimentalFeatures\"\
    \"\n\nApplyFlags\x12\x14\n\x05flags\x18\x01\x20\x01(\rR\x05flags\"#\n\tC\
    hangePin\x12\x16\n\x06remove\x18\x01\x20\x01(\x08R\x06remove\"(\n\x0eCha\
    ngeWipeCode\x12\x16\n\x06remove\x18\x01\x20\x01(\x08R\x06remove\"\xaa\
    \x01\n\tSdProtect\x12]\n\toperation\x18\x01\x20\x01(\x0e2?.hw.trezor.mes\
    sages.management.SdProtect.SdProtectOperationTypeR\toperation\">\n\x16Sd\
    ProtectOperationType\x12\x0b\n\x07DISABLE\x10\0\x12\n\n\x06ENABLE\x10\
    \x01\x12\x0b\n\x07REFRESH\x10\x02\"M\n\x04Ping\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07message\x12+\n\x11button_protection\x18\x02\x20\x01(\
    \x08R\x10buttonProtection\"\x08\n\x06Cancel\"\x20\n\nGetEntropy\x12\x12\
    \n\x04size\x18\x01\x20\x02(\rR\x04size\"#\n\x07Entropy\x12\x18\n\x07entr\
    opy\x18\x01\x20\x02(\x0cR\x07entropy\"\x0c\n\nWipeDevice\"\xb0\x02\n\nLo\
    adDevice\x12\x1c\n\tmnemonics\x18\x01\x20\x03(\tR\tmnemonics\x12\x10\n\
    \x03pin\x18\x03\x20\x01(\tR\x03pin\x123\n\x15passphrase_protection\x18\
    \x04\x20\x01(\x08R\x14passphraseProtection\x12!\n\x08language\x18\x05\
    \x20\x01(\t:\x05en-USR\x08language\x12\x14\n\x05label\x18\x06\x20\x01(\t\
    R\x05label\x12#\n\rskip_checksum\x18\x07\x20\x01(\x08R\x0cskipChecksum\
    \x12\x1f\n\x0bu2f_counter\x18\x08\x20\x01(\rR\nu2fCounter\x12!\n\x0cneed\
    s_backup\x18\t\x20\x01(\x08R\x0bneedsBackup\x12\x1b\n\tno_backup\x18\n\
    \x20\x01(\x08R\x08noBackup\"\x9c\x03\n\x0bResetDevice\x12%\n\x0edisplay_\
    random\x18\x01\x20\x01(\x08R\rdisplayRandom\x12\x1f\n\x08strength\x18\
    \x02\x20\x01(\r:\x03256R\x08strength\x123\n\x15passphrase_protection\x18\
    \x03\x20\x01(\x08R\x14passphraseProtection\x12%\n\x0epin_protection\x18\
    \x04\x20\x01(\x08R\rpinProtection\x12!\n\x08language\x18\x05\x20\x01(\t:\
    \x05en-USR\x08language\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\
    \x12\x1f\n\x0bu2f_counter\x18\x07\x20\x01(\rR\nu2fCounter\x12\x1f\n\x0bs\
    kip_backup\x18\x08\x20\x01(\x08R\nskipBackup\x12\x1b\n\tno_backup\x18\t\
    \x20\x01(\x08R\x08noBackup\x12Q\n\x0bbackup_type\x18\n\x20\x01(\x0e2).hw\
    .trezor.messages.management.BackupType:\x05Bip39R\nbackupType\"\x0e\n\
    \x0cBackupDevice\"\x10\n\x0eEntropyRequest\"&\n\nEntropyAck\x12\x18\n\
    \x07entropy\x18\x01\x20\x01(\x0cR\x07entropy\"\xd4\x03\n\x0eRecoveryDevi\
    ce\x12\x1d\n\nword_count\x18\x01\x20\x01(\rR\twordCount\x123\n\x15passph\
    rase_protection\x18\x02\x20\x01(\x08R\x14passphraseProtection\x12%\n\x0e\
    pin_protection\x18\x03\x20\x01(\x08R\rpinProtection\x12\x1a\n\x08languag\
    e\x18\x04\x20\x01(\tR\x08language\x12\x14\n\x05label\x18\x05\x20\x01(\tR\
    \x05label\x12)\n\x10enforce_wordlist\x18\x06\x20\x01(\x08R\x0fenforceWor\
    dlist\x12T\n\x04type\x18\x08\x20\x01(\x0e2@.hw.trezor.messages.managemen\
    t.RecoveryDevice.RecoveryDeviceTypeR\x04type\x12\x1f\n\x0bu2f_counter\
    \x18\t\x20\x01(\rR\nu2fCounter\x12\x17\n\x07dry_run\x18\n\x20\x01(\x08R\
    \x06dryRun\"Z\n\x12RecoveryDeviceType\x12%\n!RecoveryDeviceType_Scramble\
    dWords\x10\0\x12\x1d\n\x19RecoveryDeviceType_Matrix\x10\x01\"\xc5\x01\n\
    \x0bWordRequest\x12N\n\x04type\x18\x01\x20\x01(\x0e2:.hw.trezor.messages\
    .management.WordRequest.WordRequestTypeR\x04type\"f\n\x0fWordRequestType\
    \x12\x19\n\x15WordRequestType_Plain\x10\0\x12\x1b\n\x17WordRequestType_M\
    atrix9\x10\x01\x12\x1b\n\x17WordRequestType_Matrix6\x10\x02\"\x1d\n\x07W\
    ordAck\x12\x12\n\x04word\x18\x01\x20\x02(\tR\x04word\"0\n\rSetU2FCounter\
    \x12\x1f\n\x0bu2f_counter\x18\x01\x20\x01(\rR\nu2fCounter\"\x13\n\x11Get\
    NextU2FCounter\"1\n\x0eNextU2FCounter\x12\x1f\n\x0bu2f_counter\x18\x01\
    \x20\x01(\rR\nu2fCounter\"\x11\n\x0fDoPreauthorized\"\x16\n\x14Preauthor\
    izedRequest\"\x15\n\x13CancelAuthorization*>\n\nBackupType\x12\t\n\x05Bi\
    p39\x10\0\x12\x10\n\x0cSlip39_Basic\x10\x01\x12\x13\n\x0fSlip39_Advanced\
    \x10\x02*G\n\x10SafetyCheckLevel\x12\n\n\x06Strict\x10\0\x12\x10\n\x0cPr\
    omptAlways\x10\x01\x12\x15\n\x11PromptTemporarily\x10\x02B>\n#com.satosh\
    ilabs.trezor.lib.protobufB\x17TrezorMessageManagement\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
