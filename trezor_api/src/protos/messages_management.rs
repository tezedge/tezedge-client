// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Initialize {
    // message fields
    state: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    skip_passphrase: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Initialize {
    pub fn new() -> Initialize {
        ::std::default::Default::default()
    }

    // optional bytes state = 1;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        self.state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_state(&self) -> &[u8] {
        match self.state.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool skip_passphrase = 2;

    pub fn clear_skip_passphrase(&mut self) {
        self.skip_passphrase = ::std::option::Option::None;
    }

    pub fn has_skip_passphrase(&self) -> bool {
        self.skip_passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_passphrase(&mut self, v: bool) {
        self.skip_passphrase = ::std::option::Option::Some(v);
    }

    pub fn get_skip_passphrase(&self) -> bool {
        self.skip_passphrase.unwrap_or(false)
    }
}

impl ::protobuf::Message for Initialize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.state)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_passphrase = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.skip_passphrase {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.skip_passphrase {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Initialize {
        Initialize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "state",
                    |m: &Initialize| { &m.state },
                    |m: &mut Initialize| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "skip_passphrase",
                    |m: &Initialize| { &m.skip_passphrase },
                    |m: &mut Initialize| { &mut m.skip_passphrase },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Initialize>(
                    "Initialize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Initialize {
        static mut instance: ::protobuf::lazy::Lazy<Initialize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Initialize,
        };
        unsafe {
            instance.get(Initialize::new)
        }
    }
}

impl ::protobuf::Clear for Initialize {
    fn clear(&mut self) {
        self.clear_state();
        self.clear_skip_passphrase();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Initialize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initialize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFeatures {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetFeatures {
    pub fn new() -> GetFeatures {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFeatures {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFeatures {
        GetFeatures::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFeatures>(
                    "GetFeatures",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFeatures {
        static mut instance: ::protobuf::lazy::Lazy<GetFeatures> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFeatures,
        };
        unsafe {
            instance.get(GetFeatures::new)
        }
    }
}

impl ::protobuf::Clear for GetFeatures {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatures {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Features {
    // message fields
    vendor: ::protobuf::SingularField<::std::string::String>,
    major_version: ::std::option::Option<u32>,
    minor_version: ::std::option::Option<u32>,
    patch_version: ::std::option::Option<u32>,
    bootloader_mode: ::std::option::Option<bool>,
    device_id: ::protobuf::SingularField<::std::string::String>,
    pin_protection: ::std::option::Option<bool>,
    passphrase_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    initialized: ::std::option::Option<bool>,
    revision: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bootloader_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    imported: ::std::option::Option<bool>,
    pin_cached: ::std::option::Option<bool>,
    passphrase_cached: ::std::option::Option<bool>,
    firmware_present: ::std::option::Option<bool>,
    needs_backup: ::std::option::Option<bool>,
    flags: ::std::option::Option<u32>,
    model: ::protobuf::SingularField<::std::string::String>,
    fw_major: ::std::option::Option<u32>,
    fw_minor: ::std::option::Option<u32>,
    fw_patch: ::std::option::Option<u32>,
    fw_vendor: ::protobuf::SingularField<::std::string::String>,
    fw_vendor_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unfinished_backup: ::std::option::Option<bool>,
    no_backup: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    // optional string vendor = 1;

    pub fn clear_vendor(&mut self) {
        self.vendor.clear();
    }

    pub fn has_vendor(&self) -> bool {
        self.vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self.vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
        if self.vendor.is_none() {
            self.vendor.set_default();
        }
        self.vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_vendor(&self) -> &str {
        match self.vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 major_version = 2;

    pub fn clear_major_version(&mut self) {
        self.major_version = ::std::option::Option::None;
    }

    pub fn has_major_version(&self) -> bool {
        self.major_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_version(&mut self, v: u32) {
        self.major_version = ::std::option::Option::Some(v);
    }

    pub fn get_major_version(&self) -> u32 {
        self.major_version.unwrap_or(0)
    }

    // optional uint32 minor_version = 3;

    pub fn clear_minor_version(&mut self) {
        self.minor_version = ::std::option::Option::None;
    }

    pub fn has_minor_version(&self) -> bool {
        self.minor_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_version(&mut self, v: u32) {
        self.minor_version = ::std::option::Option::Some(v);
    }

    pub fn get_minor_version(&self) -> u32 {
        self.minor_version.unwrap_or(0)
    }

    // optional uint32 patch_version = 4;

    pub fn clear_patch_version(&mut self) {
        self.patch_version = ::std::option::Option::None;
    }

    pub fn has_patch_version(&self) -> bool {
        self.patch_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_version(&mut self, v: u32) {
        self.patch_version = ::std::option::Option::Some(v);
    }

    pub fn get_patch_version(&self) -> u32 {
        self.patch_version.unwrap_or(0)
    }

    // optional bool bootloader_mode = 5;

    pub fn clear_bootloader_mode(&mut self) {
        self.bootloader_mode = ::std::option::Option::None;
    }

    pub fn has_bootloader_mode(&self) -> bool {
        self.bootloader_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_mode(&mut self, v: bool) {
        self.bootloader_mode = ::std::option::Option::Some(v);
    }

    pub fn get_bootloader_mode(&self) -> bool {
        self.bootloader_mode.unwrap_or(false)
    }

    // optional string device_id = 6;

    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        if self.device_id.is_none() {
            self.device_id.set_default();
        }
        self.device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        self.device_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_device_id(&self) -> &str {
        match self.device_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool pin_protection = 7;

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    // optional bool passphrase_protection = 8;

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    // optional string language = 9;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string label = 10;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool initialized = 12;

    pub fn clear_initialized(&mut self) {
        self.initialized = ::std::option::Option::None;
    }

    pub fn has_initialized(&self) -> bool {
        self.initialized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialized(&mut self, v: bool) {
        self.initialized = ::std::option::Option::Some(v);
    }

    pub fn get_initialized(&self) -> bool {
        self.initialized.unwrap_or(false)
    }

    // optional bytes revision = 13;

    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes bootloader_hash = 14;

    pub fn clear_bootloader_hash(&mut self) {
        self.bootloader_hash.clear();
    }

    pub fn has_bootloader_hash(&self) -> bool {
        self.bootloader_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.bootloader_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootloader_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bootloader_hash.is_none() {
            self.bootloader_hash.set_default();
        }
        self.bootloader_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootloader_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.bootloader_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_bootloader_hash(&self) -> &[u8] {
        match self.bootloader_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool imported = 15;

    pub fn clear_imported(&mut self) {
        self.imported = ::std::option::Option::None;
    }

    pub fn has_imported(&self) -> bool {
        self.imported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imported(&mut self, v: bool) {
        self.imported = ::std::option::Option::Some(v);
    }

    pub fn get_imported(&self) -> bool {
        self.imported.unwrap_or(false)
    }

    // optional bool pin_cached = 16;

    pub fn clear_pin_cached(&mut self) {
        self.pin_cached = ::std::option::Option::None;
    }

    pub fn has_pin_cached(&self) -> bool {
        self.pin_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_cached(&mut self, v: bool) {
        self.pin_cached = ::std::option::Option::Some(v);
    }

    pub fn get_pin_cached(&self) -> bool {
        self.pin_cached.unwrap_or(false)
    }

    // optional bool passphrase_cached = 17;

    pub fn clear_passphrase_cached(&mut self) {
        self.passphrase_cached = ::std::option::Option::None;
    }

    pub fn has_passphrase_cached(&self) -> bool {
        self.passphrase_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_cached(&mut self, v: bool) {
        self.passphrase_cached = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_cached(&self) -> bool {
        self.passphrase_cached.unwrap_or(false)
    }

    // optional bool firmware_present = 18;

    pub fn clear_firmware_present(&mut self) {
        self.firmware_present = ::std::option::Option::None;
    }

    pub fn has_firmware_present(&self) -> bool {
        self.firmware_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmware_present(&mut self, v: bool) {
        self.firmware_present = ::std::option::Option::Some(v);
    }

    pub fn get_firmware_present(&self) -> bool {
        self.firmware_present.unwrap_or(false)
    }

    // optional bool needs_backup = 19;

    pub fn clear_needs_backup(&mut self) {
        self.needs_backup = ::std::option::Option::None;
    }

    pub fn has_needs_backup(&self) -> bool {
        self.needs_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_backup(&mut self, v: bool) {
        self.needs_backup = ::std::option::Option::Some(v);
    }

    pub fn get_needs_backup(&self) -> bool {
        self.needs_backup.unwrap_or(false)
    }

    // optional uint32 flags = 20;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    // optional string model = 21;

    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        self.model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 fw_major = 22;

    pub fn clear_fw_major(&mut self) {
        self.fw_major = ::std::option::Option::None;
    }

    pub fn has_fw_major(&self) -> bool {
        self.fw_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_major(&mut self, v: u32) {
        self.fw_major = ::std::option::Option::Some(v);
    }

    pub fn get_fw_major(&self) -> u32 {
        self.fw_major.unwrap_or(0)
    }

    // optional uint32 fw_minor = 23;

    pub fn clear_fw_minor(&mut self) {
        self.fw_minor = ::std::option::Option::None;
    }

    pub fn has_fw_minor(&self) -> bool {
        self.fw_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_minor(&mut self, v: u32) {
        self.fw_minor = ::std::option::Option::Some(v);
    }

    pub fn get_fw_minor(&self) -> u32 {
        self.fw_minor.unwrap_or(0)
    }

    // optional uint32 fw_patch = 24;

    pub fn clear_fw_patch(&mut self) {
        self.fw_patch = ::std::option::Option::None;
    }

    pub fn has_fw_patch(&self) -> bool {
        self.fw_patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_patch(&mut self, v: u32) {
        self.fw_patch = ::std::option::Option::Some(v);
    }

    pub fn get_fw_patch(&self) -> u32 {
        self.fw_patch.unwrap_or(0)
    }

    // optional string fw_vendor = 25;

    pub fn clear_fw_vendor(&mut self) {
        self.fw_vendor.clear();
    }

    pub fn has_fw_vendor(&self) -> bool {
        self.fw_vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_vendor(&mut self, v: ::std::string::String) {
        self.fw_vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fw_vendor(&mut self) -> &mut ::std::string::String {
        if self.fw_vendor.is_none() {
            self.fw_vendor.set_default();
        }
        self.fw_vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_fw_vendor(&mut self) -> ::std::string::String {
        self.fw_vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fw_vendor(&self) -> &str {
        match self.fw_vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes fw_vendor_keys = 26;

    pub fn clear_fw_vendor_keys(&mut self) {
        self.fw_vendor_keys.clear();
    }

    pub fn has_fw_vendor_keys(&self) -> bool {
        self.fw_vendor_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_vendor_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.fw_vendor_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fw_vendor_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fw_vendor_keys.is_none() {
            self.fw_vendor_keys.set_default();
        }
        self.fw_vendor_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_fw_vendor_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.fw_vendor_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_fw_vendor_keys(&self) -> &[u8] {
        match self.fw_vendor_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool unfinished_backup = 27;

    pub fn clear_unfinished_backup(&mut self) {
        self.unfinished_backup = ::std::option::Option::None;
    }

    pub fn has_unfinished_backup(&self) -> bool {
        self.unfinished_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unfinished_backup(&mut self, v: bool) {
        self.unfinished_backup = ::std::option::Option::Some(v);
    }

    pub fn get_unfinished_backup(&self) -> bool {
        self.unfinished_backup.unwrap_or(false)
    }

    // optional bool no_backup = 28;

    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    pub fn get_no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }
}

impl ::protobuf::Message for Features {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vendor)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.major_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minor_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.patch_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bootloader_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.initialized = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.revision)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bootloader_hash)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.imported = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_cached = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_cached = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.firmware_present = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_backup = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_major = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_minor = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fw_patch = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fw_vendor)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fw_vendor_keys)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unfinished_backup = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_backup = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.major_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.patch_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bootloader_mode {
            my_size += 2;
        }
        if let Some(ref v) = self.device_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.initialized {
            my_size += 2;
        }
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(ref v) = self.bootloader_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.imported {
            my_size += 2;
        }
        if let Some(v) = self.pin_cached {
            my_size += 3;
        }
        if let Some(v) = self.passphrase_cached {
            my_size += 3;
        }
        if let Some(v) = self.firmware_present {
            my_size += 3;
        }
        if let Some(v) = self.needs_backup {
            my_size += 3;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.fw_major {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fw_minor {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fw_patch {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fw_vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(ref v) = self.fw_vendor_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(26, &v);
        }
        if let Some(v) = self.unfinished_backup {
            my_size += 3;
        }
        if let Some(v) = self.no_backup {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vendor.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.major_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minor_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.patch_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bootloader_mode {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.device_id.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.initialized {
            os.write_bool(12, v)?;
        }
        if let Some(ref v) = self.revision.as_ref() {
            os.write_bytes(13, &v)?;
        }
        if let Some(ref v) = self.bootloader_hash.as_ref() {
            os.write_bytes(14, &v)?;
        }
        if let Some(v) = self.imported {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.pin_cached {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.passphrase_cached {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.firmware_present {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.needs_backup {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(20, v)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.fw_major {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.fw_minor {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.fw_patch {
            os.write_uint32(24, v)?;
        }
        if let Some(ref v) = self.fw_vendor.as_ref() {
            os.write_string(25, &v)?;
        }
        if let Some(ref v) = self.fw_vendor_keys.as_ref() {
            os.write_bytes(26, &v)?;
        }
        if let Some(v) = self.unfinished_backup {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(28, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Features {
        Features::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vendor",
                    |m: &Features| { &m.vendor },
                    |m: &mut Features| { &mut m.vendor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "major_version",
                    |m: &Features| { &m.major_version },
                    |m: &mut Features| { &mut m.major_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minor_version",
                    |m: &Features| { &m.minor_version },
                    |m: &mut Features| { &mut m.minor_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "patch_version",
                    |m: &Features| { &m.patch_version },
                    |m: &mut Features| { &mut m.patch_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bootloader_mode",
                    |m: &Features| { &m.bootloader_mode },
                    |m: &mut Features| { &mut m.bootloader_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_id",
                    |m: &Features| { &m.device_id },
                    |m: &mut Features| { &mut m.device_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pin_protection",
                    |m: &Features| { &m.pin_protection },
                    |m: &mut Features| { &mut m.pin_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_protection",
                    |m: &Features| { &m.passphrase_protection },
                    |m: &mut Features| { &mut m.passphrase_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &Features| { &m.language },
                    |m: &mut Features| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Features| { &m.label },
                    |m: &mut Features| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "initialized",
                    |m: &Features| { &m.initialized },
                    |m: &mut Features| { &mut m.initialized },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "revision",
                    |m: &Features| { &m.revision },
                    |m: &mut Features| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bootloader_hash",
                    |m: &Features| { &m.bootloader_hash },
                    |m: &mut Features| { &mut m.bootloader_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "imported",
                    |m: &Features| { &m.imported },
                    |m: &mut Features| { &mut m.imported },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pin_cached",
                    |m: &Features| { &m.pin_cached },
                    |m: &mut Features| { &mut m.pin_cached },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_cached",
                    |m: &Features| { &m.passphrase_cached },
                    |m: &mut Features| { &mut m.passphrase_cached },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "firmware_present",
                    |m: &Features| { &m.firmware_present },
                    |m: &mut Features| { &mut m.firmware_present },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needs_backup",
                    |m: &Features| { &m.needs_backup },
                    |m: &mut Features| { &mut m.needs_backup },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &Features| { &m.flags },
                    |m: &mut Features| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "model",
                    |m: &Features| { &m.model },
                    |m: &mut Features| { &mut m.model },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fw_major",
                    |m: &Features| { &m.fw_major },
                    |m: &mut Features| { &mut m.fw_major },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fw_minor",
                    |m: &Features| { &m.fw_minor },
                    |m: &mut Features| { &mut m.fw_minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fw_patch",
                    |m: &Features| { &m.fw_patch },
                    |m: &mut Features| { &mut m.fw_patch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fw_vendor",
                    |m: &Features| { &m.fw_vendor },
                    |m: &mut Features| { &mut m.fw_vendor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "fw_vendor_keys",
                    |m: &Features| { &m.fw_vendor_keys },
                    |m: &mut Features| { &mut m.fw_vendor_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unfinished_backup",
                    |m: &Features| { &m.unfinished_backup },
                    |m: &mut Features| { &mut m.unfinished_backup },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_backup",
                    |m: &Features| { &m.no_backup },
                    |m: &mut Features| { &mut m.no_backup },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Features>(
                    "Features",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Features {
        static mut instance: ::protobuf::lazy::Lazy<Features> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Features,
        };
        unsafe {
            instance.get(Features::new)
        }
    }
}

impl ::protobuf::Clear for Features {
    fn clear(&mut self) {
        self.clear_vendor();
        self.clear_major_version();
        self.clear_minor_version();
        self.clear_patch_version();
        self.clear_bootloader_mode();
        self.clear_device_id();
        self.clear_pin_protection();
        self.clear_passphrase_protection();
        self.clear_language();
        self.clear_label();
        self.clear_initialized();
        self.clear_revision();
        self.clear_bootloader_hash();
        self.clear_imported();
        self.clear_pin_cached();
        self.clear_passphrase_cached();
        self.clear_firmware_present();
        self.clear_needs_backup();
        self.clear_flags();
        self.clear_model();
        self.clear_fw_major();
        self.clear_fw_minor();
        self.clear_fw_patch();
        self.clear_fw_vendor();
        self.clear_fw_vendor_keys();
        self.clear_unfinished_backup();
        self.clear_no_backup();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearSession {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ClearSession {
    pub fn new() -> ClearSession {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClearSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearSession {
        ClearSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ClearSession>(
                    "ClearSession",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClearSession {
        static mut instance: ::protobuf::lazy::Lazy<ClearSession> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearSession,
        };
        unsafe {
            instance.get(ClearSession::new)
        }
    }
}

impl ::protobuf::Clear for ClearSession {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearSession {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplySettings {
    // message fields
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    use_passphrase: ::std::option::Option<bool>,
    homescreen: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    passphrase_source: ::std::option::Option<ApplySettings_PassphraseSourceType>,
    auto_lock_delay_ms: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ApplySettings {
    pub fn new() -> ApplySettings {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string label = 2;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool use_passphrase = 3;

    pub fn clear_use_passphrase(&mut self) {
        self.use_passphrase = ::std::option::Option::None;
    }

    pub fn has_use_passphrase(&self) -> bool {
        self.use_passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_passphrase(&mut self, v: bool) {
        self.use_passphrase = ::std::option::Option::Some(v);
    }

    pub fn get_use_passphrase(&self) -> bool {
        self.use_passphrase.unwrap_or(false)
    }

    // optional bytes homescreen = 4;

    pub fn clear_homescreen(&mut self) {
        self.homescreen.clear();
    }

    pub fn has_homescreen(&self) -> bool {
        self.homescreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen(&mut self, v: ::std::vec::Vec<u8>) {
        self.homescreen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_homescreen(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.homescreen.is_none() {
            self.homescreen.set_default();
        }
        self.homescreen.as_mut().unwrap()
    }

    // Take field
    pub fn take_homescreen(&mut self) -> ::std::vec::Vec<u8> {
        self.homescreen.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_homescreen(&self) -> &[u8] {
        match self.homescreen.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .hw.trezor.messages.management.ApplySettings.PassphraseSourceType passphrase_source = 5;

    pub fn clear_passphrase_source(&mut self) {
        self.passphrase_source = ::std::option::Option::None;
    }

    pub fn has_passphrase_source(&self) -> bool {
        self.passphrase_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_source(&mut self, v: ApplySettings_PassphraseSourceType) {
        self.passphrase_source = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_source(&self) -> ApplySettings_PassphraseSourceType {
        self.passphrase_source.unwrap_or(ApplySettings_PassphraseSourceType::ASK)
    }

    // optional uint32 auto_lock_delay_ms = 6;

    pub fn clear_auto_lock_delay_ms(&mut self) {
        self.auto_lock_delay_ms = ::std::option::Option::None;
    }

    pub fn has_auto_lock_delay_ms(&self) -> bool {
        self.auto_lock_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_lock_delay_ms(&mut self, v: u32) {
        self.auto_lock_delay_ms = ::std::option::Option::Some(v);
    }

    pub fn get_auto_lock_delay_ms(&self) -> u32 {
        self.auto_lock_delay_ms.unwrap_or(0)
    }
}

impl ::protobuf::Message for ApplySettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_passphrase = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.homescreen)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.passphrase_source, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auto_lock_delay_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.use_passphrase {
            my_size += 2;
        }
        if let Some(ref v) = self.homescreen.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.passphrase_source {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.auto_lock_delay_ms {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.use_passphrase {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.homescreen.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.passphrase_source {
            os.write_enum(5, v.value())?;
        }
        if let Some(v) = self.auto_lock_delay_ms {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplySettings {
        ApplySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &ApplySettings| { &m.language },
                    |m: &mut ApplySettings| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ApplySettings| { &m.label },
                    |m: &mut ApplySettings| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_passphrase",
                    |m: &ApplySettings| { &m.use_passphrase },
                    |m: &mut ApplySettings| { &mut m.use_passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "homescreen",
                    |m: &ApplySettings| { &m.homescreen },
                    |m: &mut ApplySettings| { &mut m.homescreen },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ApplySettings_PassphraseSourceType>>(
                    "passphrase_source",
                    |m: &ApplySettings| { &m.passphrase_source },
                    |m: &mut ApplySettings| { &mut m.passphrase_source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "auto_lock_delay_ms",
                    |m: &ApplySettings| { &m.auto_lock_delay_ms },
                    |m: &mut ApplySettings| { &mut m.auto_lock_delay_ms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplySettings>(
                    "ApplySettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplySettings {
        static mut instance: ::protobuf::lazy::Lazy<ApplySettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplySettings,
        };
        unsafe {
            instance.get(ApplySettings::new)
        }
    }
}

impl ::protobuf::Clear for ApplySettings {
    fn clear(&mut self) {
        self.clear_language();
        self.clear_label();
        self.clear_use_passphrase();
        self.clear_homescreen();
        self.clear_passphrase_source();
        self.clear_auto_lock_delay_ms();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ApplySettings_PassphraseSourceType {
    ASK = 0,
    DEVICE = 1,
    HOST = 2,
}

impl ::protobuf::ProtobufEnum for ApplySettings_PassphraseSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ApplySettings_PassphraseSourceType> {
        match value {
            0 => ::std::option::Option::Some(ApplySettings_PassphraseSourceType::ASK),
            1 => ::std::option::Option::Some(ApplySettings_PassphraseSourceType::DEVICE),
            2 => ::std::option::Option::Some(ApplySettings_PassphraseSourceType::HOST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ApplySettings_PassphraseSourceType] = &[
            ApplySettings_PassphraseSourceType::ASK,
            ApplySettings_PassphraseSourceType::DEVICE,
            ApplySettings_PassphraseSourceType::HOST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ApplySettings_PassphraseSourceType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ApplySettings_PassphraseSourceType {
}

impl ::protobuf::reflect::ProtobufValue for ApplySettings_PassphraseSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplyFlags {
    // message fields
    flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ApplyFlags {
    pub fn new() -> ApplyFlags {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
}

impl ::protobuf::Message for ApplyFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplyFlags {
        ApplyFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &ApplyFlags| { &m.flags },
                    |m: &mut ApplyFlags| { &mut m.flags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplyFlags>(
                    "ApplyFlags",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplyFlags {
        static mut instance: ::protobuf::lazy::Lazy<ApplyFlags> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplyFlags,
        };
        unsafe {
            instance.get(ApplyFlags::new)
        }
    }
}

impl ::protobuf::Clear for ApplyFlags {
    fn clear(&mut self) {
        self.clear_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplyFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePin {
    // message fields
    remove: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChangePin {
    pub fn new() -> ChangePin {
        ::std::default::Default::default()
    }

    // optional bool remove = 1;

    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }

    pub fn get_remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }
}

impl ::protobuf::Message for ChangePin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.remove {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.remove {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePin {
        ChangePin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remove",
                    |m: &ChangePin| { &m.remove },
                    |m: &mut ChangePin| { &mut m.remove },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangePin>(
                    "ChangePin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangePin {
        static mut instance: ::protobuf::lazy::Lazy<ChangePin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangePin,
        };
        unsafe {
            instance.get(ChangePin::new)
        }
    }
}

impl ::protobuf::Clear for ChangePin {
    fn clear(&mut self) {
        self.clear_remove();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    button_protection: ::std::option::Option<bool>,
    pin_protection: ::std::option::Option<bool>,
    passphrase_protection: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool button_protection = 2;

    pub fn clear_button_protection(&mut self) {
        self.button_protection = ::std::option::Option::None;
    }

    pub fn has_button_protection(&self) -> bool {
        self.button_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_protection(&mut self, v: bool) {
        self.button_protection = ::std::option::Option::Some(v);
    }

    pub fn get_button_protection(&self) -> bool {
        self.button_protection.unwrap_or(false)
    }

    // optional bool pin_protection = 3;

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    // optional bool passphrase_protection = 4;

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.button_protection = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.button_protection {
            my_size += 2;
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.button_protection {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &Ping| { &m.message },
                    |m: &mut Ping| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "button_protection",
                    |m: &Ping| { &m.button_protection },
                    |m: &mut Ping| { &mut m.button_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pin_protection",
                    |m: &Ping| { &m.pin_protection },
                    |m: &mut Ping| { &mut m.pin_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_protection",
                    |m: &Ping| { &m.passphrase_protection },
                    |m: &mut Ping| { &mut m.passphrase_protection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ping>(
                    "Ping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ping {
        static mut instance: ::protobuf::lazy::Lazy<Ping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ping,
        };
        unsafe {
            instance.get(Ping::new)
        }
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_button_protection();
        self.clear_pin_protection();
        self.clear_passphrase_protection();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cancel {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Cancel {
    pub fn new() -> Cancel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Cancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cancel {
        Cancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Cancel>(
                    "Cancel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cancel {
        static mut instance: ::protobuf::lazy::Lazy<Cancel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cancel,
        };
        unsafe {
            instance.get(Cancel::new)
        }
    }
}

impl ::protobuf::Clear for Cancel {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cancel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEntropy {
    // message fields
    size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetEntropy {
    pub fn new() -> GetEntropy {
        ::std::default::Default::default()
    }

    // required uint32 size = 1;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetEntropy {
    fn is_initialized(&self) -> bool {
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.size {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEntropy {
        GetEntropy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &GetEntropy| { &m.size },
                    |m: &mut GetEntropy| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEntropy>(
                    "GetEntropy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEntropy {
        static mut instance: ::protobuf::lazy::Lazy<GetEntropy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEntropy,
        };
        unsafe {
            instance.get(GetEntropy::new)
        }
    }
}

impl ::protobuf::Clear for GetEntropy {
    fn clear(&mut self) {
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEntropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEntropy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entropy {
    // message fields
    entropy: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Entropy {
    pub fn new() -> Entropy {
        ::std::default::Default::default()
    }

    // required bytes entropy = 1;

    pub fn clear_entropy(&mut self) {
        self.entropy.clear();
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy.set_default();
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Entropy {
    fn is_initialized(&self) -> bool {
        if self.entropy.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entropy.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entropy {
        Entropy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "entropy",
                    |m: &Entropy| { &m.entropy },
                    |m: &mut Entropy| { &mut m.entropy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Entropy>(
                    "Entropy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Entropy {
        static mut instance: ::protobuf::lazy::Lazy<Entropy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Entropy,
        };
        unsafe {
            instance.get(Entropy::new)
        }
    }
}

impl ::protobuf::Clear for Entropy {
    fn clear(&mut self) {
        self.clear_entropy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entropy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WipeDevice {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WipeDevice {
    pub fn new() -> WipeDevice {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WipeDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WipeDevice {
        WipeDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WipeDevice>(
                    "WipeDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WipeDevice {
        static mut instance: ::protobuf::lazy::Lazy<WipeDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WipeDevice,
        };
        unsafe {
            instance.get(WipeDevice::new)
        }
    }
}

impl ::protobuf::Clear for WipeDevice {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WipeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WipeDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadDevice {
    // message fields
    mnemonic: ::protobuf::SingularField<::std::string::String>,
    node: ::protobuf::SingularPtrField<super::messages_common::HDNodeType>,
    pin: ::protobuf::SingularField<::std::string::String>,
    passphrase_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    skip_checksum: ::std::option::Option<bool>,
    u2f_counter: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LoadDevice {
    pub fn new() -> LoadDevice {
        ::std::default::Default::default()
    }

    // optional string mnemonic = 1;

    pub fn clear_mnemonic(&mut self) {
        self.mnemonic.clear();
    }

    pub fn has_mnemonic(&self) -> bool {
        self.mnemonic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mnemonic(&mut self, v: ::std::string::String) {
        self.mnemonic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mnemonic(&mut self) -> &mut ::std::string::String {
        if self.mnemonic.is_none() {
            self.mnemonic.set_default();
        }
        self.mnemonic.as_mut().unwrap()
    }

    // Take field
    pub fn take_mnemonic(&mut self) -> ::std::string::String {
        self.mnemonic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_mnemonic(&self) -> &str {
        match self.mnemonic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .hw.trezor.messages.common.HDNodeType node = 2;

    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: super::messages_common::HDNodeType) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut super::messages_common::HDNodeType {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> super::messages_common::HDNodeType {
        self.node.take().unwrap_or_else(|| super::messages_common::HDNodeType::new())
    }

    pub fn get_node(&self) -> &super::messages_common::HDNodeType {
        self.node.as_ref().unwrap_or_else(|| super::messages_common::HDNodeType::default_instance())
    }

    // optional string pin = 3;

    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool passphrase_protection = 4;

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    // optional string language = 5;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "english",
        }
    }

    // optional string label = 6;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool skip_checksum = 7;

    pub fn clear_skip_checksum(&mut self) {
        self.skip_checksum = ::std::option::Option::None;
    }

    pub fn has_skip_checksum(&self) -> bool {
        self.skip_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_checksum(&mut self, v: bool) {
        self.skip_checksum = ::std::option::Option::Some(v);
    }

    pub fn get_skip_checksum(&self) -> bool {
        self.skip_checksum.unwrap_or(false)
    }

    // optional uint32 u2f_counter = 8;

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
}

impl ::protobuf::Message for LoadDevice {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mnemonic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pin)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_checksum = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mnemonic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.skip_checksum {
            my_size += 2;
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mnemonic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pin.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.skip_checksum {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadDevice {
        LoadDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mnemonic",
                    |m: &LoadDevice| { &m.mnemonic },
                    |m: &mut LoadDevice| { &mut m.mnemonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::messages_common::HDNodeType>>(
                    "node",
                    |m: &LoadDevice| { &m.node },
                    |m: &mut LoadDevice| { &mut m.node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pin",
                    |m: &LoadDevice| { &m.pin },
                    |m: &mut LoadDevice| { &mut m.pin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_protection",
                    |m: &LoadDevice| { &m.passphrase_protection },
                    |m: &mut LoadDevice| { &mut m.passphrase_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &LoadDevice| { &m.language },
                    |m: &mut LoadDevice| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &LoadDevice| { &m.label },
                    |m: &mut LoadDevice| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "skip_checksum",
                    |m: &LoadDevice| { &m.skip_checksum },
                    |m: &mut LoadDevice| { &mut m.skip_checksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "u2f_counter",
                    |m: &LoadDevice| { &m.u2f_counter },
                    |m: &mut LoadDevice| { &mut m.u2f_counter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoadDevice>(
                    "LoadDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoadDevice {
        static mut instance: ::protobuf::lazy::Lazy<LoadDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoadDevice,
        };
        unsafe {
            instance.get(LoadDevice::new)
        }
    }
}

impl ::protobuf::Clear for LoadDevice {
    fn clear(&mut self) {
        self.clear_mnemonic();
        self.clear_node();
        self.clear_pin();
        self.clear_passphrase_protection();
        self.clear_language();
        self.clear_label();
        self.clear_skip_checksum();
        self.clear_u2f_counter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetDevice {
    // message fields
    display_random: ::std::option::Option<bool>,
    strength: ::std::option::Option<u32>,
    passphrase_protection: ::std::option::Option<bool>,
    pin_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    u2f_counter: ::std::option::Option<u32>,
    skip_backup: ::std::option::Option<bool>,
    no_backup: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ResetDevice {
    pub fn new() -> ResetDevice {
        ::std::default::Default::default()
    }

    // optional bool display_random = 1;

    pub fn clear_display_random(&mut self) {
        self.display_random = ::std::option::Option::None;
    }

    pub fn has_display_random(&self) -> bool {
        self.display_random.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_random(&mut self, v: bool) {
        self.display_random = ::std::option::Option::Some(v);
    }

    pub fn get_display_random(&self) -> bool {
        self.display_random.unwrap_or(false)
    }

    // optional uint32 strength = 2;

    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: u32) {
        self.strength = ::std::option::Option::Some(v);
    }

    pub fn get_strength(&self) -> u32 {
        self.strength.unwrap_or(256u32)
    }

    // optional bool passphrase_protection = 3;

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    // optional bool pin_protection = 4;

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    // optional string language = 5;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "english",
        }
    }

    // optional string label = 6;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 u2f_counter = 7;

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    // optional bool skip_backup = 8;

    pub fn clear_skip_backup(&mut self) {
        self.skip_backup = ::std::option::Option::None;
    }

    pub fn has_skip_backup(&self) -> bool {
        self.skip_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_backup(&mut self, v: bool) {
        self.skip_backup = ::std::option::Option::Some(v);
    }

    pub fn get_skip_backup(&self) -> bool {
        self.skip_backup.unwrap_or(false)
    }

    // optional bool no_backup = 9;

    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    pub fn get_no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }
}

impl ::protobuf::Message for ResetDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.display_random = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_backup = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_backup = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display_random {
            my_size += 2;
        }
        if let Some(v) = self.strength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skip_backup {
            my_size += 2;
        }
        if let Some(v) = self.no_backup {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display_random {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.strength {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.skip_backup {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetDevice {
        ResetDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "display_random",
                    |m: &ResetDevice| { &m.display_random },
                    |m: &mut ResetDevice| { &mut m.display_random },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "strength",
                    |m: &ResetDevice| { &m.strength },
                    |m: &mut ResetDevice| { &mut m.strength },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_protection",
                    |m: &ResetDevice| { &m.passphrase_protection },
                    |m: &mut ResetDevice| { &mut m.passphrase_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pin_protection",
                    |m: &ResetDevice| { &m.pin_protection },
                    |m: &mut ResetDevice| { &mut m.pin_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &ResetDevice| { &m.language },
                    |m: &mut ResetDevice| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ResetDevice| { &m.label },
                    |m: &mut ResetDevice| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "u2f_counter",
                    |m: &ResetDevice| { &m.u2f_counter },
                    |m: &mut ResetDevice| { &mut m.u2f_counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "skip_backup",
                    |m: &ResetDevice| { &m.skip_backup },
                    |m: &mut ResetDevice| { &mut m.skip_backup },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_backup",
                    |m: &ResetDevice| { &m.no_backup },
                    |m: &mut ResetDevice| { &mut m.no_backup },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResetDevice>(
                    "ResetDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResetDevice {
        static mut instance: ::protobuf::lazy::Lazy<ResetDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResetDevice,
        };
        unsafe {
            instance.get(ResetDevice::new)
        }
    }
}

impl ::protobuf::Clear for ResetDevice {
    fn clear(&mut self) {
        self.clear_display_random();
        self.clear_strength();
        self.clear_passphrase_protection();
        self.clear_pin_protection();
        self.clear_language();
        self.clear_label();
        self.clear_u2f_counter();
        self.clear_skip_backup();
        self.clear_no_backup();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupDevice {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BackupDevice {
    pub fn new() -> BackupDevice {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackupDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupDevice {
        BackupDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<BackupDevice>(
                    "BackupDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BackupDevice {
        static mut instance: ::protobuf::lazy::Lazy<BackupDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BackupDevice,
        };
        unsafe {
            instance.get(BackupDevice::new)
        }
    }
}

impl ::protobuf::Clear for BackupDevice {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntropyRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EntropyRequest {
    pub fn new() -> EntropyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EntropyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntropyRequest {
        EntropyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EntropyRequest>(
                    "EntropyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntropyRequest {
        static mut instance: ::protobuf::lazy::Lazy<EntropyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntropyRequest,
        };
        unsafe {
            instance.get(EntropyRequest::new)
        }
    }
}

impl ::protobuf::Clear for EntropyRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntropyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntropyAck {
    // message fields
    entropy: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EntropyAck {
    pub fn new() -> EntropyAck {
        ::std::default::Default::default()
    }

    // optional bytes entropy = 1;

    pub fn clear_entropy(&mut self) {
        self.entropy.clear();
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy.set_default();
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for EntropyAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entropy.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntropyAck {
        EntropyAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "entropy",
                    |m: &EntropyAck| { &m.entropy },
                    |m: &mut EntropyAck| { &mut m.entropy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntropyAck>(
                    "EntropyAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntropyAck {
        static mut instance: ::protobuf::lazy::Lazy<EntropyAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntropyAck,
        };
        unsafe {
            instance.get(EntropyAck::new)
        }
    }
}

impl ::protobuf::Clear for EntropyAck {
    fn clear(&mut self) {
        self.clear_entropy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntropyAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoveryDevice {
    // message fields
    word_count: ::std::option::Option<u32>,
    passphrase_protection: ::std::option::Option<bool>,
    pin_protection: ::std::option::Option<bool>,
    language: ::protobuf::SingularField<::std::string::String>,
    label: ::protobuf::SingularField<::std::string::String>,
    enforce_wordlist: ::std::option::Option<bool>,
    field_type: ::std::option::Option<RecoveryDevice_RecoveryDeviceType>,
    u2f_counter: ::std::option::Option<u32>,
    dry_run: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RecoveryDevice {
    pub fn new() -> RecoveryDevice {
        ::std::default::Default::default()
    }

    // optional uint32 word_count = 1;

    pub fn clear_word_count(&mut self) {
        self.word_count = ::std::option::Option::None;
    }

    pub fn has_word_count(&self) -> bool {
        self.word_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_count(&mut self, v: u32) {
        self.word_count = ::std::option::Option::Some(v);
    }

    pub fn get_word_count(&self) -> u32 {
        self.word_count.unwrap_or(0)
    }

    // optional bool passphrase_protection = 2;

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    pub fn get_passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    // optional bool pin_protection = 3;

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    pub fn get_pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    // optional string language = 4;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "english",
        }
    }

    // optional string label = 5;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool enforce_wordlist = 6;

    pub fn clear_enforce_wordlist(&mut self) {
        self.enforce_wordlist = ::std::option::Option::None;
    }

    pub fn has_enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enforce_wordlist(&mut self, v: bool) {
        self.enforce_wordlist = ::std::option::Option::Some(v);
    }

    pub fn get_enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.unwrap_or(false)
    }

    // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: RecoveryDevice_RecoveryDeviceType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> RecoveryDevice_RecoveryDeviceType {
        self.field_type.unwrap_or(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords)
    }

    // optional uint32 u2f_counter = 9;

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    // optional bool dry_run = 10;

    pub fn clear_dry_run(&mut self) {
        self.dry_run = ::std::option::Option::None;
    }

    pub fn has_dry_run(&self) -> bool {
        self.dry_run.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dry_run(&mut self, v: bool) {
        self.dry_run = ::std::option::Option::Some(v);
    }

    pub fn get_dry_run(&self) -> bool {
        self.dry_run.unwrap_or(false)
    }
}

impl ::protobuf::Message for RecoveryDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.word_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphrase_protection = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pin_protection = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enforce_wordlist = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dry_run = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.word_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 2;
        }
        if let Some(v) = self.pin_protection {
            my_size += 2;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.enforce_wordlist {
            my_size += 2;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dry_run {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.word_count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.enforce_wordlist {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.dry_run {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoveryDevice {
        RecoveryDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "word_count",
                    |m: &RecoveryDevice| { &m.word_count },
                    |m: &mut RecoveryDevice| { &mut m.word_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passphrase_protection",
                    |m: &RecoveryDevice| { &m.passphrase_protection },
                    |m: &mut RecoveryDevice| { &mut m.passphrase_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pin_protection",
                    |m: &RecoveryDevice| { &m.pin_protection },
                    |m: &mut RecoveryDevice| { &mut m.pin_protection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &RecoveryDevice| { &m.language },
                    |m: &mut RecoveryDevice| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &RecoveryDevice| { &m.label },
                    |m: &mut RecoveryDevice| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enforce_wordlist",
                    |m: &RecoveryDevice| { &m.enforce_wordlist },
                    |m: &mut RecoveryDevice| { &mut m.enforce_wordlist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RecoveryDevice_RecoveryDeviceType>>(
                    "type",
                    |m: &RecoveryDevice| { &m.field_type },
                    |m: &mut RecoveryDevice| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "u2f_counter",
                    |m: &RecoveryDevice| { &m.u2f_counter },
                    |m: &mut RecoveryDevice| { &mut m.u2f_counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dry_run",
                    |m: &RecoveryDevice| { &m.dry_run },
                    |m: &mut RecoveryDevice| { &mut m.dry_run },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoveryDevice>(
                    "RecoveryDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RecoveryDevice {
        static mut instance: ::protobuf::lazy::Lazy<RecoveryDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoveryDevice,
        };
        unsafe {
            instance.get(RecoveryDevice::new)
        }
    }
}

impl ::protobuf::Clear for RecoveryDevice {
    fn clear(&mut self) {
        self.clear_word_count();
        self.clear_passphrase_protection();
        self.clear_pin_protection();
        self.clear_language();
        self.clear_label();
        self.clear_enforce_wordlist();
        self.clear_field_type();
        self.clear_u2f_counter();
        self.clear_dry_run();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoveryDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveryDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RecoveryDevice_RecoveryDeviceType {
    RecoveryDeviceType_ScrambledWords = 0,
    RecoveryDeviceType_Matrix = 1,
}

impl ::protobuf::ProtobufEnum for RecoveryDevice_RecoveryDeviceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecoveryDevice_RecoveryDeviceType> {
        match value {
            0 => ::std::option::Option::Some(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords),
            1 => ::std::option::Option::Some(RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_Matrix),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RecoveryDevice_RecoveryDeviceType] = &[
            RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_ScrambledWords,
            RecoveryDevice_RecoveryDeviceType::RecoveryDeviceType_Matrix,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RecoveryDevice_RecoveryDeviceType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RecoveryDevice_RecoveryDeviceType {
}

impl ::protobuf::reflect::ProtobufValue for RecoveryDevice_RecoveryDeviceType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WordRequest {
    // message fields
    field_type: ::std::option::Option<WordRequest_WordRequestType>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WordRequest {
    pub fn new() -> WordRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: WordRequest_WordRequestType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> WordRequest_WordRequestType {
        self.field_type.unwrap_or(WordRequest_WordRequestType::WordRequestType_Plain)
    }
}

impl ::protobuf::Message for WordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WordRequest {
        WordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WordRequest_WordRequestType>>(
                    "type",
                    |m: &WordRequest| { &m.field_type },
                    |m: &mut WordRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WordRequest>(
                    "WordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WordRequest {
        static mut instance: ::protobuf::lazy::Lazy<WordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WordRequest,
        };
        unsafe {
            instance.get(WordRequest::new)
        }
    }
}

impl ::protobuf::Clear for WordRequest {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WordRequest_WordRequestType {
    WordRequestType_Plain = 0,
    WordRequestType_Matrix9 = 1,
    WordRequestType_Matrix6 = 2,
}

impl ::protobuf::ProtobufEnum for WordRequest_WordRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WordRequest_WordRequestType> {
        match value {
            0 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Plain),
            1 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Matrix9),
            2 => ::std::option::Option::Some(WordRequest_WordRequestType::WordRequestType_Matrix6),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WordRequest_WordRequestType] = &[
            WordRequest_WordRequestType::WordRequestType_Plain,
            WordRequest_WordRequestType::WordRequestType_Matrix9,
            WordRequest_WordRequestType::WordRequestType_Matrix6,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WordRequest_WordRequestType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WordRequest_WordRequestType {
}

impl ::protobuf::reflect::ProtobufValue for WordRequest_WordRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WordAck {
    // message fields
    word: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WordAck {
    pub fn new() -> WordAck {
        ::std::default::Default::default()
    }

    // required string word = 1;

    pub fn clear_word(&mut self) {
        self.word.clear();
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word.set_default();
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for WordAck {
    fn is_initialized(&self) -> bool {
        if self.word.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.word)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.word.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WordAck {
        WordAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "word",
                    |m: &WordAck| { &m.word },
                    |m: &mut WordAck| { &mut m.word },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WordAck>(
                    "WordAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WordAck {
        static mut instance: ::protobuf::lazy::Lazy<WordAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WordAck,
        };
        unsafe {
            instance.get(WordAck::new)
        }
    }
}

impl ::protobuf::Clear for WordAck {
    fn clear(&mut self) {
        self.clear_word();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WordAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetU2FCounter {
    // message fields
    u2f_counter: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SetU2FCounter {
    pub fn new() -> SetU2FCounter {
        ::std::default::Default::default()
    }

    // optional uint32 u2f_counter = 1;

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    pub fn get_u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }
}

impl ::protobuf::Message for SetU2FCounter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.u2f_counter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.u2f_counter {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetU2FCounter {
        SetU2FCounter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "u2f_counter",
                    |m: &SetU2FCounter| { &m.u2f_counter },
                    |m: &mut SetU2FCounter| { &mut m.u2f_counter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetU2FCounter>(
                    "SetU2FCounter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetU2FCounter {
        static mut instance: ::protobuf::lazy::Lazy<SetU2FCounter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetU2FCounter,
        };
        unsafe {
            instance.get(SetU2FCounter::new)
        }
    }
}

impl ::protobuf::Clear for SetU2FCounter {
    fn clear(&mut self) {
        self.clear_u2f_counter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetU2FCounter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19messages-management.proto\x12\x1dhw.trezor.messages.management\x1a\
    \x15messages-common.proto\"K\n\nInitialize\x12\x14\n\x05state\x18\x01\
    \x20\x01(\x0cR\x05state\x12'\n\x0fskip_passphrase\x18\x02\x20\x01(\x08R\
    \x0eskipPassphrase\"\r\n\x0bGetFeatures\"\x8c\x07\n\x08Features\x12\x16\
    \n\x06vendor\x18\x01\x20\x01(\tR\x06vendor\x12#\n\rmajor_version\x18\x02\
    \x20\x01(\rR\x0cmajorVersion\x12#\n\rminor_version\x18\x03\x20\x01(\rR\
    \x0cminorVersion\x12#\n\rpatch_version\x18\x04\x20\x01(\rR\x0cpatchVersi\
    on\x12'\n\x0fbootloader_mode\x18\x05\x20\x01(\x08R\x0ebootloaderMode\x12\
    \x1b\n\tdevice_id\x18\x06\x20\x01(\tR\x08deviceId\x12%\n\x0epin_protecti\
    on\x18\x07\x20\x01(\x08R\rpinProtection\x123\n\x15passphrase_protection\
    \x18\x08\x20\x01(\x08R\x14passphraseProtection\x12\x1a\n\x08language\x18\
    \t\x20\x01(\tR\x08language\x12\x14\n\x05label\x18\n\x20\x01(\tR\x05label\
    \x12\x20\n\x0binitialized\x18\x0c\x20\x01(\x08R\x0binitialized\x12\x1a\n\
    \x08revision\x18\r\x20\x01(\x0cR\x08revision\x12'\n\x0fbootloader_hash\
    \x18\x0e\x20\x01(\x0cR\x0ebootloaderHash\x12\x1a\n\x08imported\x18\x0f\
    \x20\x01(\x08R\x08imported\x12\x1d\n\npin_cached\x18\x10\x20\x01(\x08R\t\
    pinCached\x12+\n\x11passphrase_cached\x18\x11\x20\x01(\x08R\x10passphras\
    eCached\x12)\n\x10firmware_present\x18\x12\x20\x01(\x08R\x0ffirmwarePres\
    ent\x12!\n\x0cneeds_backup\x18\x13\x20\x01(\x08R\x0bneedsBackup\x12\x14\
    \n\x05flags\x18\x14\x20\x01(\rR\x05flags\x12\x14\n\x05model\x18\x15\x20\
    \x01(\tR\x05model\x12\x19\n\x08fw_major\x18\x16\x20\x01(\rR\x07fwMajor\
    \x12\x19\n\x08fw_minor\x18\x17\x20\x01(\rR\x07fwMinor\x12\x19\n\x08fw_pa\
    tch\x18\x18\x20\x01(\rR\x07fwPatch\x12\x1b\n\tfw_vendor\x18\x19\x20\x01(\
    \tR\x08fwVendor\x12$\n\x0efw_vendor_keys\x18\x1a\x20\x01(\x0cR\x0cfwVend\
    orKeys\x12+\n\x11unfinished_backup\x18\x1b\x20\x01(\x08R\x10unfinishedBa\
    ckup\x12\x1b\n\tno_backup\x18\x1c\x20\x01(\x08R\x08noBackup\"\x0e\n\x0cC\
    learSession\"\xdc\x02\n\rApplySettings\x12\x1a\n\x08language\x18\x01\x20\
    \x01(\tR\x08language\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\
    %\n\x0euse_passphrase\x18\x03\x20\x01(\x08R\rusePassphrase\x12\x1e\n\nho\
    mescreen\x18\x04\x20\x01(\x0cR\nhomescreen\x12n\n\x11passphrase_source\
    \x18\x05\x20\x01(\x0e2A.hw.trezor.messages.management.ApplySettings.Pass\
    phraseSourceTypeR\x10passphraseSource\x12+\n\x12auto_lock_delay_ms\x18\
    \x06\x20\x01(\rR\x0fautoLockDelayMs\"5\n\x14PassphraseSourceType\x12\x07\
    \n\x03ASK\x10\0\x12\n\n\x06DEVICE\x10\x01\x12\x08\n\x04HOST\x10\x02\"\"\
    \n\nApplyFlags\x12\x14\n\x05flags\x18\x01\x20\x01(\rR\x05flags\"#\n\tCha\
    ngePin\x12\x16\n\x06remove\x18\x01\x20\x01(\x08R\x06remove\"\xa9\x01\n\
    \x04Ping\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x12+\n\x11b\
    utton_protection\x18\x02\x20\x01(\x08R\x10buttonProtection\x12%\n\x0epin\
    _protection\x18\x03\x20\x01(\x08R\rpinProtection\x123\n\x15passphrase_pr\
    otection\x18\x04\x20\x01(\x08R\x14passphraseProtection\"\x08\n\x06Cancel\
    \"\x20\n\nGetEntropy\x12\x12\n\x04size\x18\x01\x20\x02(\rR\x04size\"#\n\
    \x07Entropy\x12\x18\n\x07entropy\x18\x01\x20\x02(\x0cR\x07entropy\"\x0c\
    \n\nWipeDevice\"\xab\x02\n\nLoadDevice\x12\x1a\n\x08mnemonic\x18\x01\x20\
    \x01(\tR\x08mnemonic\x129\n\x04node\x18\x02\x20\x01(\x0b2%.hw.trezor.mes\
    sages.common.HDNodeTypeR\x04node\x12\x10\n\x03pin\x18\x03\x20\x01(\tR\
    \x03pin\x123\n\x15passphrase_protection\x18\x04\x20\x01(\x08R\x14passphr\
    aseProtection\x12#\n\x08language\x18\x05\x20\x01(\t:\x07englishR\x08lang\
    uage\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\x12#\n\rskip_checks\
    um\x18\x07\x20\x01(\x08R\x0cskipChecksum\x12\x1f\n\x0bu2f_counter\x18\
    \x08\x20\x01(\rR\nu2fCounter\"\xcb\x02\n\x0bResetDevice\x12%\n\x0edispla\
    y_random\x18\x01\x20\x01(\x08R\rdisplayRandom\x12\x1f\n\x08strength\x18\
    \x02\x20\x01(\r:\x03256R\x08strength\x123\n\x15passphrase_protection\x18\
    \x03\x20\x01(\x08R\x14passphraseProtection\x12%\n\x0epin_protection\x18\
    \x04\x20\x01(\x08R\rpinProtection\x12#\n\x08language\x18\x05\x20\x01(\t:\
    \x07englishR\x08language\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\
    \x12\x1f\n\x0bu2f_counter\x18\x07\x20\x01(\rR\nu2fCounter\x12\x1f\n\x0bs\
    kip_backup\x18\x08\x20\x01(\x08R\nskipBackup\x12\x1b\n\tno_backup\x18\t\
    \x20\x01(\x08R\x08noBackup\"\x0e\n\x0cBackupDevice\"\x10\n\x0eEntropyReq\
    uest\"&\n\nEntropyAck\x12\x18\n\x07entropy\x18\x01\x20\x01(\x0cR\x07entr\
    opy\"\xdd\x03\n\x0eRecoveryDevice\x12\x1d\n\nword_count\x18\x01\x20\x01(\
    \rR\twordCount\x123\n\x15passphrase_protection\x18\x02\x20\x01(\x08R\x14\
    passphraseProtection\x12%\n\x0epin_protection\x18\x03\x20\x01(\x08R\rpin\
    Protection\x12#\n\x08language\x18\x04\x20\x01(\t:\x07englishR\x08languag\
    e\x12\x14\n\x05label\x18\x05\x20\x01(\tR\x05label\x12)\n\x10enforce_word\
    list\x18\x06\x20\x01(\x08R\x0fenforceWordlist\x12T\n\x04type\x18\x08\x20\
    \x01(\x0e2@.hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceT\
    ypeR\x04type\x12\x1f\n\x0bu2f_counter\x18\t\x20\x01(\rR\nu2fCounter\x12\
    \x17\n\x07dry_run\x18\n\x20\x01(\x08R\x06dryRun\"Z\n\x12RecoveryDeviceTy\
    pe\x12%\n!RecoveryDeviceType_ScrambledWords\x10\0\x12\x1d\n\x19RecoveryD\
    eviceType_Matrix\x10\x01\"\xc5\x01\n\x0bWordRequest\x12N\n\x04type\x18\
    \x01\x20\x01(\x0e2:.hw.trezor.messages.management.WordRequest.WordReques\
    tTypeR\x04type\"f\n\x0fWordRequestType\x12\x19\n\x15WordRequestType_Plai\
    n\x10\0\x12\x1b\n\x17WordRequestType_Matrix9\x10\x01\x12\x1b\n\x17WordRe\
    questType_Matrix6\x10\x02\"\x1d\n\x07WordAck\x12\x12\n\x04word\x18\x01\
    \x20\x02(\tR\x04word\"0\n\rSetU2FCounter\x12\x1f\n\x0bu2f_counter\x18\
    \x01\x20\x01(\rR\nu2fCounterB>\n#com.satoshilabs.trezor.lib.protobufB\
    \x17TrezorMessageManagementJ\xc7Z\n\x07\x12\x05\0\0\x9b\x02\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\x08%\n\x08\n\x01\
    \x08\x12\x03\x04\0<\n.\n\x02\x08\x01\x12\x03\x04\0<\x1a#\x20Sugar\x20for\
    \x20easier\x20handling\x20in\x20Java\n\n\x08\n\x01\x08\x12\x03\x05\08\n\
    \t\n\x02\x08\x08\x12\x03\x05\08\n\t\n\x02\x03\0\x12\x03\x07\x07\x1e\ni\n\
    \x02\x04\0\x12\x04\x0e\0\x11\x01\x1a]*\n\x20Request:\x20Reset\x20device\
    \x20to\x20default\x20state\x20and\x20ask\x20for\x20device\x20details\n\
    \x20@start\n\x20@next\x20Features\n\n\n\n\x03\x04\0\x01\x12\x03\x0e\x08\
    \x12\nG\n\x04\x04\0\x02\0\x12\x03\x0f\x04\x1d\":\x20assumed\x20device\
    \x20state,\x20clear\x20session\x20if\x20set\x20and\x20different\n\n\x0c\
    \n\x05\x04\0\x02\0\x04\x12\x03\x0f\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x0f\r\x12\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0f\x13\x18\n\x0c\
    \n\x05\x04\0\x02\0\x03\x12\x03\x0f\x1b\x1c\nA\n\x04\x04\0\x02\x01\x12\
    \x03\x10\x04&\"4\x20this\x20session\x20should\x20always\x20assume\x20emp\
    ty\x20passphrase\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x10\x04\x0c\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x10\r\x11\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x10\x12!\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x10$%\nY\n\
    \x02\x04\x01\x12\x04\x18\0\x19\x01\x1aM*\n\x20Request:\x20Ask\x20for\x20\
    device\x20details\x20(no\x20device\x20reset)\n\x20@start\n\x20@next\x20F\
    eatures\n\n\n\n\x03\x04\x01\x01\x12\x03\x18\x08\x13\nL\n\x02\x04\x02\x12\
    \x04\x1f\0;\x01\x1a@*\n\x20Response:\x20Reports\x20various\x20informatio\
    n\x20about\x20the\x20device\n\x20@end\n\n\n\n\x03\x04\x02\x01\x12\x03\
    \x1f\x08\x10\n9\n\x04\x04\x02\x02\0\x12\x03\x20\x04\x1f\",\x20name\x20of\
    \x20the\x20manufacturer,\x20e.g.\x20\"trezor.io\"\n\n\x0c\n\x05\x04\x02\
    \x02\0\x04\x12\x03\x20\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x20\
    \r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x20\x14\x1a\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03\x20\x1d\x1e\n?\n\x04\x04\x02\x02\x01\x12\x03!\x04\
    &\"2\x20major\x20version\x20of\x20the\x20firmware/bootloader,\x20e.g.\
    \x201\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03!\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x03!\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03!\
    \x14!\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03!$%\n?\n\x04\x04\x02\x02\
    \x02\x12\x03\"\x04&\"2\x20minor\x20version\x20of\x20the\x20firmware/boot\
    loader,\x20e.g.\x200\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03\"\x04\x0c\
    \n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\"\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03\"\x14!\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\"$%\n?\n\
    \x04\x04\x02\x02\x03\x12\x03#\x04&\"2\x20patch\x20version\x20of\x20the\
    \x20firmware/bootloader,\x20e.g.\x200\n\n\x0c\n\x05\x04\x02\x02\x03\x04\
    \x12\x03#\x04\x0c\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03#\r\x13\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x03#\x14!\n\x0c\n\x05\x04\x02\x02\x03\x03\
    \x12\x03#$%\n,\n\x04\x04\x02\x02\x04\x12\x03$\x04&\"\x1f\x20is\x20device\
    \x20in\x20bootloader\x20mode?\n\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03$\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03$\r\x11\n\x0c\n\x05\x04\
    \x02\x02\x04\x01\x12\x03$\x12!\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03$$\
    %\n)\n\x04\x04\x02\x02\x05\x12\x03%\x04\"\"\x1c\x20device's\x20unique\
    \x20identifier\n\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03%\x04\x0c\n\x0c\
    \n\x05\x04\x02\x02\x05\x05\x12\x03%\r\x13\n\x0c\n\x05\x04\x02\x02\x05\
    \x01\x12\x03%\x14\x1d\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03%\x20!\n*\n\
    \x04\x04\x02\x02\x06\x12\x03&\x04%\"\x1d\x20is\x20device\x20protected\
    \x20by\x20PIN?\n\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03&\x04\x0c\n\x0c\
    \n\x05\x04\x02\x02\x06\x05\x12\x03&\r\x11\n\x0c\n\x05\x04\x02\x02\x06\
    \x01\x12\x03&\x12\x20\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03&#$\n;\n\
    \x04\x04\x02\x02\x07\x12\x03'\x04,\".\x20is\x20node/mnemonic\x20encrypte\
    d\x20using\x20passphrase?\n\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03'\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03'\r\x11\n\x0c\n\x05\x04\x02\
    \x02\x07\x01\x12\x03'\x12'\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03'*+\n\
    \x1e\n\x04\x04\x02\x02\x08\x12\x03(\x04!\"\x11\x20device\x20language\n\n\
    \x0c\n\x05\x04\x02\x02\x08\x04\x12\x03(\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x08\x05\x12\x03(\r\x13\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03(\x14\x1c\
    \n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03(\x1f\x20\n'\n\x04\x04\x02\x02\t\
    \x12\x03)\x04\x1f\"\x1a\x20device\x20description\x20label\n\n\x0c\n\x05\
    \x04\x02\x02\t\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\x02\x02\t\x05\x12\
    \x03)\r\x13\n\x0c\n\x05\x04\x02\x02\t\x01\x12\x03)\x14\x19\n\x0c\n\x05\
    \x04\x02\x02\t\x03\x12\x03)\x1c\x1e\n(\n\x04\x04\x02\x02\n\x12\x03*\x04#\
    \"\x1b\x20does\x20device\x20contain\x20seed?\n\n\x0c\n\x05\x04\x02\x02\n\
    \x04\x12\x03*\x04\x0c\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03*\r\x11\n\x0c\
    \n\x05\x04\x02\x02\n\x01\x12\x03*\x12\x1d\n\x0c\n\x05\x04\x02\x02\n\x03\
    \x12\x03*\x20\"\n'\n\x04\x04\x02\x02\x0b\x12\x03+\x04!\"\x1a\x20SCM\x20r\
    evision\x20of\x20firmware\n\n\x0c\n\x05\x04\x02\x02\x0b\x04\x12\x03+\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x0b\x05\x12\x03+\r\x12\n\x0c\n\x05\x04\x02\
    \x02\x0b\x01\x12\x03+\x13\x1b\n\x0c\n\x05\x04\x02\x02\x0b\x03\x12\x03+\
    \x1e\x20\n%\n\x04\x04\x02\x02\x0c\x12\x03,\x04(\"\x18\x20hash\x20of\x20t\
    he\x20bootloader\n\n\x0c\n\x05\x04\x02\x02\x0c\x04\x12\x03,\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x0c\x05\x12\x03,\r\x12\n\x0c\n\x05\x04\x02\x02\
    \x0c\x01\x12\x03,\x13\"\n\x0c\n\x05\x04\x02\x02\x0c\x03\x12\x03,%'\n<\n\
    \x04\x04\x02\x02\r\x12\x03-\x04\x20\"/\x20was\x20storage\x20imported\x20\
    from\x20an\x20external\x20source?\n\n\x0c\n\x05\x04\x02\x02\r\x04\x12\
    \x03-\x04\x0c\n\x0c\n\x05\x04\x02\x02\r\x05\x12\x03-\r\x11\n\x0c\n\x05\
    \x04\x02\x02\r\x01\x12\x03-\x12\x1a\n\x0c\n\x05\x04\x02\x02\r\x03\x12\
    \x03-\x1d\x1f\n0\n\x04\x04\x02\x02\x0e\x12\x03.\x04\"\"#\x20is\x20PIN\
    \x20already\x20cached\x20in\x20session?\n\n\x0c\n\x05\x04\x02\x02\x0e\
    \x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0e\x05\x12\x03.\r\x11\n\
    \x0c\n\x05\x04\x02\x02\x0e\x01\x12\x03.\x12\x1c\n\x0c\n\x05\x04\x02\x02\
    \x0e\x03\x12\x03.\x1f!\n7\n\x04\x04\x02\x02\x0f\x12\x03/\x04)\"*\x20is\
    \x20passphrase\x20already\x20cached\x20in\x20session?\n\n\x0c\n\x05\x04\
    \x02\x02\x0f\x04\x12\x03/\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0f\x05\x12\
    \x03/\r\x11\n\x0c\n\x05\x04\x02\x02\x0f\x01\x12\x03/\x12#\n\x0c\n\x05\
    \x04\x02\x02\x0f\x03\x12\x03/&(\n(\n\x04\x04\x02\x02\x10\x12\x030\x04(\"\
    \x1b\x20is\x20valid\x20firmware\x20loaded?\n\n\x0c\n\x05\x04\x02\x02\x10\
    \x04\x12\x030\x04\x0c\n\x0c\n\x05\x04\x02\x02\x10\x05\x12\x030\r\x11\n\
    \x0c\n\x05\x04\x02\x02\x10\x01\x12\x030\x12\"\n\x0c\n\x05\x04\x02\x02\
    \x10\x03\x12\x030%'\nI\n\x04\x04\x02\x02\x11\x12\x031\x04$\"<\x20does\
    \x20storage\x20need\x20backup?\x20(equals\x20to\x20Storage.needs_backup)\
    \n\n\x0c\n\x05\x04\x02\x02\x11\x04\x12\x031\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x11\x05\x12\x031\r\x11\n\x0c\n\x05\x04\x02\x02\x11\x01\x12\x031\x12\
    \x1e\n\x0c\n\x05\x04\x02\x02\x11\x03\x12\x031!#\n5\n\x04\x04\x02\x02\x12\
    \x12\x032\x04\x1f\"(\x20device\x20flags\x20(equals\x20to\x20Storage.flag\
    s)\n\n\x0c\n\x05\x04\x02\x02\x12\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x12\x05\x12\x032\r\x13\n\x0c\n\x05\x04\x02\x02\x12\x01\x12\x032\
    \x14\x19\n\x0c\n\x05\x04\x02\x02\x12\x03\x12\x032\x1c\x1e\n$\n\x04\x04\
    \x02\x02\x13\x12\x033\x04\x1f\"\x17\x20device\x20hardware\x20model\n\n\
    \x0c\n\x05\x04\x02\x02\x13\x04\x12\x033\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x13\x05\x12\x033\r\x13\n\x0c\n\x05\x04\x02\x02\x13\x01\x12\x033\x14\x19\
    \n\x0c\n\x05\x04\x02\x02\x13\x03\x12\x033\x1c\x1e\n>\n\x04\x04\x02\x02\
    \x14\x12\x034\x04\"\"1\x20reported\x20firmware\x20version\x20if\x20in\
    \x20bootloader\x20mode\n\n\x0c\n\x05\x04\x02\x02\x14\x04\x12\x034\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x14\x05\x12\x034\r\x13\n\x0c\n\x05\x04\x02\
    \x02\x14\x01\x12\x034\x14\x1c\n\x0c\n\x05\x04\x02\x02\x14\x03\x12\x034\
    \x1f!\n>\n\x04\x04\x02\x02\x15\x12\x035\x04\"\"1\x20reported\x20firmware\
    \x20version\x20if\x20in\x20bootloader\x20mode\n\n\x0c\n\x05\x04\x02\x02\
    \x15\x04\x12\x035\x04\x0c\n\x0c\n\x05\x04\x02\x02\x15\x05\x12\x035\r\x13\
    \n\x0c\n\x05\x04\x02\x02\x15\x01\x12\x035\x14\x1c\n\x0c\n\x05\x04\x02\
    \x02\x15\x03\x12\x035\x1f!\n>\n\x04\x04\x02\x02\x16\x12\x036\x04\"\"1\
    \x20reported\x20firmware\x20version\x20if\x20in\x20bootloader\x20mode\n\
    \n\x0c\n\x05\x04\x02\x02\x16\x04\x12\x036\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x16\x05\x12\x036\r\x13\n\x0c\n\x05\x04\x02\x02\x16\x01\x12\x036\x14\
    \x1c\n\x0c\n\x05\x04\x02\x02\x16\x03\x12\x036\x1f!\n=\n\x04\x04\x02\x02\
    \x17\x12\x037\x04#\"0\x20reported\x20firmware\x20vendor\x20if\x20in\x20b\
    ootloader\x20mode\n\n\x0c\n\x05\x04\x02\x02\x17\x04\x12\x037\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x17\x05\x12\x037\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x17\x01\x12\x037\x14\x1d\n\x0c\n\x05\x04\x02\x02\x17\x03\x12\x037\x20\"\
    \n9\n\x04\x04\x02\x02\x18\x12\x038\x04'\",\x20reported\x20firmware\x20ve\
    ndor\x20keys\x20(their\x20hash)\n\n\x0c\n\x05\x04\x02\x02\x18\x04\x12\
    \x038\x04\x0c\n\x0c\n\x05\x04\x02\x02\x18\x05\x12\x038\r\x12\n\x0c\n\x05\
    \x04\x02\x02\x18\x01\x12\x038\x13!\n\x0c\n\x05\x04\x02\x02\x18\x03\x12\
    \x038$&\nM\n\x04\x04\x02\x02\x19\x12\x039\x04)\"@\x20report\x20unfinishe\
    d\x20backup\x20(equals\x20to\x20Storage.unfinished_backup)\n\n\x0c\n\x05\
    \x04\x02\x02\x19\x04\x12\x039\x04\x0c\n\x0c\n\x05\x04\x02\x02\x19\x05\
    \x12\x039\r\x11\n\x0c\n\x05\x04\x02\x02\x19\x01\x12\x039\x12#\n\x0c\n\
    \x05\x04\x02\x02\x19\x03\x12\x039&(\n=\n\x04\x04\x02\x02\x1a\x12\x03:\
    \x04!\"0\x20report\x20no\x20backup\x20(equals\x20to\x20Storage.no_backup\
    )\n\n\x0c\n\x05\x04\x02\x02\x1a\x04\x12\x03:\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x1a\x05\x12\x03:\r\x11\n\x0c\n\x05\x04\x02\x02\x1a\x01\x12\x03:\x12\
    \x1b\n\x0c\n\x05\x04\x02\x02\x1a\x03\x12\x03:\x1e\x20\nd\n\x02\x04\x03\
    \x12\x04B\0C\x01\x1aX*\n\x20Request:\x20clear\x20session\x20(removes\x20\
    cached\x20PIN,\x20passphrase,\x20etc).\n\x20@start\n\x20@next\x20Success\
    \n\n\n\n\x03\x04\x03\x01\x12\x03B\x08\x14\ni\n\x02\x04\x04\x12\x04K\0Z\
    \x01\x1a]*\n\x20Request:\x20change\x20language\x20and/or\x20label\x20of\
    \x20the\x20device\n\x20@start\n\x20@next\x20Success\n\x20@next\x20Failur\
    e\n\n\n\n\x03\x04\x04\x01\x12\x03K\x08\x15\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03L\x04!\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03L\x04\x0c\n\x0c\n\x05\
    \x04\x04\x02\0\x05\x12\x03L\r\x13\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03L\
    \x14\x1c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03L\x1f\x20\n\x0b\n\x04\x04\
    \x04\x02\x01\x12\x03M\x04\x1e\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03M\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03M\r\x13\n\x0c\n\x05\x04\
    \x04\x02\x01\x01\x12\x03M\x14\x19\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03M\x1c\x1d\n\x0b\n\x04\x04\x04\x02\x02\x12\x03N\x04%\n\x0c\n\x05\x04\
    \x04\x02\x02\x04\x12\x03N\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03N\r\x11\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03N\x12\x20\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03N#$\n\x0b\n\x04\x04\x04\x02\x03\x12\x03O\x04\
    \"\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03O\x04\x0c\n\x0c\n\x05\x04\x04\
    \x02\x03\x05\x12\x03O\r\x12\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03O\x13\
    \x1d\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03O\x20!\n\x0b\n\x04\x04\x04\
    \x02\x04\x12\x03P\x048\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03P\x04\x0c\
    \n\x0c\n\x05\x04\x04\x02\x04\x06\x12\x03P\r!\n\x0c\n\x05\x04\x04\x02\x04\
    \x01\x12\x03P\"3\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03P67\n\x0b\n\x04\
    \x04\x04\x02\x05\x12\x03Q\x04+\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03Q\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03Q\r\x13\n\x0c\n\x05\x04\
    \x04\x02\x05\x01\x12\x03Q\x14&\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03Q)\
    *\n:\n\x04\x04\x04\x04\0\x12\x04U\x04Y\x05\x1a,*\n\x20Structure\x20repre\
    senting\x20passphrase\x20source\n\n\x0c\n\x05\x04\x04\x04\0\x01\x12\x03U\
    \t\x1d\n\r\n\x06\x04\x04\x04\0\x02\0\x12\x03V\x08\x10\n\x0e\n\x07\x04\
    \x04\x04\0\x02\0\x01\x12\x03V\x08\x0b\n\x0e\n\x07\x04\x04\x04\0\x02\0\
    \x02\x12\x03V\x0e\x0f\n\r\n\x06\x04\x04\x04\0\x02\x01\x12\x03W\x08\x13\n\
    \x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x03W\x08\x0e\n\x0e\n\x07\x04\
    \x04\x04\0\x02\x01\x02\x12\x03W\x11\x12\n\r\n\x06\x04\x04\x04\0\x02\x02\
    \x12\x03X\x08\x11\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x03X\x08\x0c\
    \n\x0e\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x03X\x0f\x10\nV\n\x02\x04\x05\
    \x12\x04b\0d\x01\x1aJ*\n\x20Request:\x20set\x20flags\x20of\x20the\x20dev\
    ice\n\x20@start\n\x20@next\x20Success\n\x20@next\x20Failure\n\n\n\n\x03\
    \x04\x05\x01\x12\x03b\x08\x12\n4\n\x04\x04\x05\x02\0\x12\x03c\x04\x1e\"'\
    \x20bitmask,\x20can\x20only\x20set\x20bits,\x20not\x20unset\n\n\x0c\n\
    \x05\x04\x05\x02\0\x04\x12\x03c\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x03c\r\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03c\x14\x19\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03c\x1c\x1d\nt\n\x02\x04\x06\x12\x04l\0n\x01\
    \x1ah*\n\x20Request:\x20Starts\x20workflow\x20for\x20setting/changing/re\
    moving\x20the\x20PIN\n\x20@start\n\x20@next\x20Success\n\x20@next\x20Fai\
    lure\n\n\n\n\x03\x04\x06\x01\x12\x03l\x08\x11\n(\n\x04\x04\x06\x02\0\x12\
    \x03m\x04\x1d\"\x1b\x20is\x20PIN\x20removal\x20requested?\n\n\x0c\n\x05\
    \x04\x06\x02\0\x04\x12\x03m\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03m\r\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03m\x12\x18\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03m\x1b\x1c\n~\n\x02\x04\x07\x12\x04u\0z\x01\x1a\
    r*\n\x20Request:\x20Test\x20if\x20the\x20device\x20is\x20alive,\x20devic\
    e\x20sends\x20back\x20the\x20message\x20in\x20Success\x20response\n\x20@\
    start\n\x20@next\x20Success\n\n\n\n\x03\x04\x07\x01\x12\x03u\x08\x0c\n6\
    \n\x04\x04\x07\x02\0\x12\x03v\x04\x20\")\x20message\x20to\x20send\x20bac\
    k\x20in\x20Success\x20message\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03v\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03v\r\x13\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03v\x14\x1b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03v\
    \x1e\x1f\n#\n\x04\x04\x07\x02\x01\x12\x03w\x04(\"\x16\x20ask\x20for\x20b\
    utton\x20press\n\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03w\x04\x0c\n\x0c\
    \n\x05\x04\x07\x02\x01\x05\x12\x03w\r\x11\n\x0c\n\x05\x04\x07\x02\x01\
    \x01\x12\x03w\x12#\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03w&'\n+\n\x04\
    \x04\x07\x02\x02\x12\x03x\x04%\"\x1e\x20ask\x20for\x20PIN\x20if\x20set\
    \x20in\x20device\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03x\x04\x0c\n\
    \x0c\n\x05\x04\x07\x02\x02\x05\x12\x03x\r\x11\n\x0c\n\x05\x04\x07\x02\
    \x02\x01\x12\x03x\x12\x20\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03x#$\n2\
    \n\x04\x04\x07\x02\x03\x12\x03y\x04,\"%\x20ask\x20for\x20passphrase\x20i\
    f\x20set\x20in\x20device\n\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03y\x04\
    \x0c\n\x0c\n\x05\x04\x07\x02\x03\x05\x12\x03y\r\x11\n\x0c\n\x05\x04\x07\
    \x02\x03\x01\x12\x03y\x12'\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03y*+\ne\
    \n\x02\x04\x08\x12\x06\x81\x01\0\x82\x01\x01\x1aW*\n\x20Request:\x20Abor\
    t\x20last\x20operation\x20that\x20required\x20user\x20interaction\n\x20@\
    start\n\x20@next\x20Failure\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x81\x01\
    \x08\x0e\n\x95\x01\n\x02\x04\t\x12\x06\x8a\x01\0\x8c\x01\x01\x1a\x86\x01\
    *\n\x20Request:\x20Request\x20a\x20sample\x20of\x20random\x20data\x20gen\
    erated\x20by\x20hardware\x20RNG.\x20May\x20be\x20used\x20for\x20testing.\
    \n\x20@start\n\x20@next\x20Entropy\n\x20@next\x20Failure\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\x8a\x01\x08\x12\n)\n\x04\x04\t\x02\0\x12\x04\x8b\x01\
    \x04\x1d\"\x1b\x20size\x20of\x20requested\x20entropy\n\n\r\n\x05\x04\t\
    \x02\0\x04\x12\x04\x8b\x01\x04\x0c\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x8b\
    \x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x8b\x01\x14\x18\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x8b\x01\x1b\x1c\nR\n\x02\x04\n\x12\x06\x92\x01\
    \0\x94\x01\x01\x1aD*\n\x20Response:\x20Reply\x20with\x20random\x20data\
    \x20generated\x20by\x20internal\x20RNG\n\x20@end\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\x92\x01\x08\x0f\n/\n\x04\x04\n\x02\0\x12\x04\x93\x01\x04\x1f\"!\
    \x20chunk\x20of\x20random\x20generated\x20bytes\n\n\r\n\x05\x04\n\x02\0\
    \x04\x12\x04\x93\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x93\x01\r\
    \x12\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x93\x01\x13\x1a\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x93\x01\x1d\x1e\nw\n\x02\x04\x0b\x12\x06\x9c\x01\0\
    \x9d\x01\x01\x1ai*\n\x20Request:\x20Request\x20device\x20to\x20wipe\x20a\
    ll\x20sensitive\x20data\x20and\x20settings\n\x20@start\n\x20@next\x20Suc\
    cess\n\x20@next\x20Failure\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x9c\x01\x08\
    \x12\nz\n\x02\x04\x0c\x12\x06\xa5\x01\0\xae\x01\x01\x1al*\n\x20Request:\
    \x20Load\x20seed\x20and\x20related\x20internal\x20settings\x20from\x20th\
    e\x20computer\n\x20@start\n\x20@next\x20Success\n\x20@next\x20Failure\n\
    \n\x0b\n\x03\x04\x0c\x01\x12\x04\xa5\x01\x08\x12\nD\n\x04\x04\x0c\x02\0\
    \x12\x04\xa6\x01\x04!\"6\x20seed\x20encoded\x20as\x20BIP-39\x20mnemonic\
    \x20(12,\x2018\x20or\x2024\x20words)\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\xa6\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xa6\x01\r\x13\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa6\x01\x14\x1c\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\xa6\x01\x1f\x20\n\x1b\n\x04\x04\x0c\x02\x01\x12\x04\xa7\
    \x01\x04;\"\r\x20BIP-32\x20node\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\
    \xa7\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xa7\x01\r1\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\xa7\x0126\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xa7\x019:\n\"\n\x04\x04\x0c\x02\x02\x12\x04\xa8\x01\x04\x1c\"\
    \x14\x20set\x20PIN\x20protection\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\
    \xa8\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xa8\x01\r\x13\n\r\
    \n\x05\x04\x0c\x02\x02\x01\x12\x04\xa8\x01\x14\x17\n\r\n\x05\x04\x0c\x02\
    \x02\x03\x12\x04\xa8\x01\x1a\x1b\n>\n\x04\x04\x0c\x02\x03\x12\x04\xa9\
    \x01\x04,\"0\x20enable\x20master\x20node\x20encryption\x20using\x20passp\
    hrase\n\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\xa9\x01\x04\x0c\n\r\n\x05\
    \x04\x0c\x02\x03\x05\x12\x04\xa9\x01\r\x11\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\xa9\x01\x12'\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xa9\x01*+\n\
    \x1f\n\x04\x04\x0c\x02\x04\x12\x04\xaa\x01\x045\"\x11\x20device\x20langu\
    age\n\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\xaa\x01\x04\x0c\n\r\n\x05\
    \x04\x0c\x02\x04\x05\x12\x04\xaa\x01\r\x13\n\r\n\x05\x04\x0c\x02\x04\x01\
    \x12\x04\xaa\x01\x14\x1c\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xaa\x01\
    \x1f\x20\n\r\n\x05\x04\x0c\x02\x04\x08\x12\x04\xaa\x01!4\n\r\n\x05\x04\
    \x0c\x02\x04\x07\x12\x04\xaa\x01*3\n\x1c\n\x04\x04\x0c\x02\x05\x12\x04\
    \xab\x01\x04\x1e\"\x0e\x20device\x20label\n\n\r\n\x05\x04\x0c\x02\x05\
    \x04\x12\x04\xab\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xab\
    \x01\r\x13\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xab\x01\x14\x19\n\r\n\
    \x05\x04\x0c\x02\x05\x03\x12\x04\xab\x01\x1c\x1d\n>\n\x04\x04\x0c\x02\
    \x06\x12\x04\xac\x01\x04$\"0\x20do\x20not\x20test\x20mnemonic\x20for\x20\
    valid\x20BIP-39\x20checksum\n\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\xac\
    \x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xac\x01\r\x11\n\r\n\
    \x05\x04\x0c\x02\x06\x01\x12\x04\xac\x01\x12\x1f\n\r\n\x05\x04\x0c\x02\
    \x06\x03\x12\x04\xac\x01\"#\n\x1b\n\x04\x04\x0c\x02\x07\x12\x04\xad\x01\
    \x04$\"\r\x20U2F\x20counter\n\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xad\
    \x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\xad\x01\r\x13\n\r\n\
    \x05\x04\x0c\x02\x07\x01\x12\x04\xad\x01\x14\x1f\n\r\n\x05\x04\x0c\x02\
    \x07\x03\x12\x04\xad\x01\"#\n\x82\x01\n\x02\x04\r\x12\x06\xb6\x01\0\xc0\
    \x01\x01\x1at*\n\x20Request:\x20Ask\x20device\x20to\x20do\x20initializat\
    ion\x20involving\x20user\x20interaction\n\x20@start\n\x20@next\x20Entrop\
    yRequest\n\x20@next\x20Failure\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb6\x01\
    \x08\x13\n\\\n\x04\x04\r\x02\0\x12\x04\xb7\x01\x04%\"N\x20display\x20ent\
    ropy\x20generated\x20by\x20the\x20device\x20before\x20asking\x20for\x20a\
    dditional\x20entropy\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xb7\x01\x04\x0c\
    \n\r\n\x05\x04\r\x02\0\x05\x12\x04\xb7\x01\r\x11\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xb7\x01\x12\x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb7\x01#$\
    \n(\n\x04\x04\r\x02\x01\x12\x04\xb8\x01\x04/\"\x1a\x20strength\x20of\x20\
    seed\x20in\x20bits\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xb8\x01\x04\x0c\
    \n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xb8\x01\r\x13\n\r\n\x05\x04\r\x02\
    \x01\x01\x12\x04\xb8\x01\x14\x1c\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xb8\
    \x01\x1f\x20\n\r\n\x05\x04\r\x02\x01\x08\x12\x04\xb8\x01!.\n\r\n\x05\x04\
    \r\x02\x01\x07\x12\x04\xb8\x01*-\n>\n\x04\x04\r\x02\x02\x12\x04\xb9\x01\
    \x04,\"0\x20enable\x20master\x20node\x20encryption\x20using\x20passphras\
    e\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xb9\x01\x04\x0c\n\r\n\x05\x04\r\
    \x02\x02\x05\x12\x04\xb9\x01\r\x11\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\
    \xb9\x01\x12'\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xb9\x01*+\n%\n\x04\x04\
    \r\x02\x03\x12\x04\xba\x01\x04%\"\x17\x20enable\x20PIN\x20protection\n\n\
    \r\n\x05\x04\r\x02\x03\x04\x12\x04\xba\x01\x04\x0c\n\r\n\x05\x04\r\x02\
    \x03\x05\x12\x04\xba\x01\r\x11\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xba\
    \x01\x12\x20\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xba\x01#$\n\x1f\n\x04\
    \x04\r\x02\x04\x12\x04\xbb\x01\x045\"\x11\x20device\x20language\n\n\r\n\
    \x05\x04\r\x02\x04\x04\x12\x04\xbb\x01\x04\x0c\n\r\n\x05\x04\r\x02\x04\
    \x05\x12\x04\xbb\x01\r\x13\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xbb\x01\
    \x14\x1c\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xbb\x01\x1f\x20\n\r\n\x05\
    \x04\r\x02\x04\x08\x12\x04\xbb\x01!4\n\r\n\x05\x04\r\x02\x04\x07\x12\x04\
    \xbb\x01*3\n\x1c\n\x04\x04\r\x02\x05\x12\x04\xbc\x01\x04\x1e\"\x0e\x20de\
    vice\x20label\n\n\r\n\x05\x04\r\x02\x05\x04\x12\x04\xbc\x01\x04\x0c\n\r\
    \n\x05\x04\r\x02\x05\x05\x12\x04\xbc\x01\r\x13\n\r\n\x05\x04\r\x02\x05\
    \x01\x12\x04\xbc\x01\x14\x19\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xbc\x01\
    \x1c\x1d\n\x1b\n\x04\x04\r\x02\x06\x12\x04\xbd\x01\x04$\"\r\x20U2F\x20co\
    unter\n\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xbd\x01\x04\x0c\n\r\n\x05\
    \x04\r\x02\x06\x05\x12\x04\xbd\x01\r\x13\n\r\n\x05\x04\r\x02\x06\x01\x12\
    \x04\xbd\x01\x14\x1f\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xbd\x01\"#\n=\n\
    \x04\x04\r\x02\x07\x12\x04\xbe\x01\x04\"\"/\x20postpone\x20seed\x20backu\
    p\x20to\x20BackupDevice\x20workflow\n\n\r\n\x05\x04\r\x02\x07\x04\x12\
    \x04\xbe\x01\x04\x0c\n\r\n\x05\x04\r\x02\x07\x05\x12\x04\xbe\x01\r\x11\n\
    \r\n\x05\x04\r\x02\x07\x01\x12\x04\xbe\x01\x12\x1d\n\r\n\x05\x04\r\x02\
    \x07\x03\x12\x04\xbe\x01\x20!\n;\n\x04\x04\r\x02\x08\x12\x04\xbf\x01\x04\
    \x20\"-\x20indicate\x20that\x20no\x20backup\x20is\x20going\x20to\x20be\
    \x20made\n\n\r\n\x05\x04\r\x02\x08\x04\x12\x04\xbf\x01\x04\x0c\n\r\n\x05\
    \x04\r\x02\x08\x05\x12\x04\xbf\x01\r\x11\n\r\n\x05\x04\r\x02\x08\x01\x12\
    \x04\xbf\x01\x12\x1b\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xbf\x01\x1e\x1f\
    \nv\n\x02\x04\x0e\x12\x06\xc7\x01\0\xc8\x01\x01\x1ah*\n\x20Request:\x20P\
    erform\x20backup\x20of\x20the\x20device\x20seed\x20if\x20not\x20backed\
    \x20up\x20using\x20ResetDevice\n\x20@start\n\x20@next\x20Success\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xc7\x01\x08\x14\n[\n\x02\x04\x0f\x12\x06\xce\
    \x01\0\xcf\x01\x01\x1aM*\n\x20Response:\x20Ask\x20for\x20additional\x20e\
    ntropy\x20from\x20host\x20computer\n\x20@next\x20EntropyAck\n\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xce\x01\x08\x16\na\n\x02\x04\x10\x12\x06\xd5\
    \x01\0\xd7\x01\x01\x1aS*\n\x20Request:\x20Provide\x20additional\x20entro\
    py\x20for\x20seed\x20generation\x20function\n\x20@next\x20Success\n\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xd5\x01\x08\x12\n2\n\x04\x04\x10\x02\0\
    \x12\x04\xd6\x01\x04\x1f\"$\x20256\x20bits\x20(32\x20bytes)\x20of\x20ran\
    dom\x20data\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xd6\x01\x04\x0c\n\r\n\
    \x05\x04\x10\x02\0\x05\x12\x04\xd6\x01\r\x12\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xd6\x01\x13\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd6\x01\x1d\
    \x1e\n\xb5\x01\n\x02\x04\x11\x12\x06\xdf\x01\0\xf7\x01\x01\x1a\xa6\x01*\
    \n\x20Request:\x20Start\x20recovery\x20workflow\x20asking\x20user\x20for\
    \x20specific\x20words\x20of\x20mnemonic\n\x20Used\x20to\x20recovery\x20d\
    evice\x20safely\x20even\x20on\x20untrusted\x20computer.\n\x20@start\n\
    \x20@next\x20WordRequest\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xdf\x01\x08\
    \x16\n2\n\x04\x04\x11\x02\0\x12\x04\xe0\x01\x04#\"$\x20number\x20of\x20w\
    ords\x20in\x20BIP-39\x20mnemonic\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \xe0\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xe0\x01\r\x13\n\r\n\
    \x05\x04\x11\x02\0\x01\x12\x04\xe0\x01\x14\x1e\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xe0\x01!\"\n>\n\x04\x04\x11\x02\x01\x12\x04\xe1\x01\x04,\"0\
    \x20enable\x20master\x20node\x20encryption\x20using\x20passphrase\n\n\r\
    \n\x05\x04\x11\x02\x01\x04\x12\x04\xe1\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x01\x05\x12\x04\xe1\x01\r\x11\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe1\
    \x01\x12'\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe1\x01*+\n%\n\x04\x04\
    \x11\x02\x02\x12\x04\xe2\x01\x04%\"\x17\x20enable\x20PIN\x20protection\n\
    \n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xe2\x01\x04\x0c\n\r\n\x05\x04\x11\
    \x02\x02\x05\x12\x04\xe2\x01\r\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\
    \xe2\x01\x12\x20\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xe2\x01#$\n\x1f\n\
    \x04\x04\x11\x02\x03\x12\x04\xe3\x01\x045\"\x11\x20device\x20language\n\
    \n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\xe3\x01\x04\x0c\n\r\n\x05\x04\x11\
    \x02\x03\x05\x12\x04\xe3\x01\r\x13\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\
    \xe3\x01\x14\x1c\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xe3\x01\x1f\x20\n\
    \r\n\x05\x04\x11\x02\x03\x08\x12\x04\xe3\x01!4\n\r\n\x05\x04\x11\x02\x03\
    \x07\x12\x04\xe3\x01*3\n\x1c\n\x04\x04\x11\x02\x04\x12\x04\xe4\x01\x04\
    \x1e\"\x0e\x20device\x20label\n\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\
    \xe4\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xe4\x01\r\x13\n\r\
    \n\x05\x04\x11\x02\x04\x01\x12\x04\xe4\x01\x14\x19\n\r\n\x05\x04\x11\x02\
    \x04\x03\x12\x04\xe4\x01\x1c\x1d\n:\n\x04\x04\x11\x02\x05\x12\x04\xe5\
    \x01\x04'\",\x20enforce\x20BIP-39\x20wordlist\x20during\x20the\x20proces\
    s\n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xe5\x01\x04\x0c\n\r\n\x05\x04\
    \x11\x02\x05\x05\x12\x04\xe5\x01\r\x11\n\r\n\x05\x04\x11\x02\x05\x01\x12\
    \x04\xe5\x01\x12\"\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xe5\x01%&\nP\n\
    \x04\x04\x11\x02\x06\x12\x04\xe7\x01\x04)\x1a'\x207\x20reserved\x20for\
    \x20unused\x20recovery\x20method\n\"\x19\x20supported\x20recovery\x20typ\
    e\n\n\r\n\x05\x04\x11\x02\x06\x04\x12\x04\xe7\x01\x04\x0c\n\r\n\x05\x04\
    \x11\x02\x06\x06\x12\x04\xe7\x01\r\x1f\n\r\n\x05\x04\x11\x02\x06\x01\x12\
    \x04\xe7\x01\x20$\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xe7\x01'(\n\x1b\
    \n\x04\x04\x11\x02\x07\x12\x04\xe8\x01\x04$\"\r\x20U2F\x20counter\n\n\r\
    \n\x05\x04\x11\x02\x07\x04\x12\x04\xe8\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x07\x05\x12\x04\xe8\x01\r\x13\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xe8\
    \x01\x14\x1f\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\xe8\x01\"#\nP\n\x04\
    \x04\x11\x02\x08\x12\x04\xe9\x01\x04\x1f\"B\x20perform\x20dry-run\x20rec\
    overy\x20workflow\x20(for\x20safe\x20mnemonic\x20validation)\n\n\r\n\x05\
    \x04\x11\x02\x08\x04\x12\x04\xe9\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x08\
    \x05\x12\x04\xe9\x01\r\x11\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xe9\x01\
    \x12\x19\n\r\n\x05\x04\x11\x02\x08\x03\x12\x04\xe9\x01\x1c\x1e\n\xd3\x02\
    \n\x04\x04\x11\x04\0\x12\x06\xf2\x01\x04\xf6\x01\x05\x1a\xc2\x02*\n\x20T\
    ype\x20of\x20recovery\x20procedure.\x20These\x20should\x20be\x20used\x20\
    as\x20bitmask,\x20e.g.,\n\x20`RecoveryDeviceType_ScrambledWords\x20|\x20\
    RecoveryDeviceType_Matrix`\n\x20listing\x20every\x20method\x20supported\
    \x20by\x20the\x20host\x20computer.\n\n\x20Note\x20that\x20ScrambledWords\
    \x20must\x20be\x20supported\x20by\x20every\x20implementation\n\x20for\
    \x20backward\x20compatibility;\x20there\x20is\x20no\x20way\x20to\x20not\
    \x20support\x20it.\n\n\r\n\x05\x04\x11\x04\0\x01\x12\x04\xf2\x01\t\x1b\n\
    Y\n\x06\x04\x11\x04\0\x02\0\x12\x04\xf4\x01\x08.\x1a-\x20use\x20powers\
    \x20of\x20two\x20when\x20extending\x20this\x20field\n\"\x1a\x20words\x20\
    in\x20scrambled\x20order\n\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\
    \xf4\x01\x08)\n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xf4\x01,-\n&\n\
    \x06\x04\x11\x04\0\x02\x01\x12\x04\xf5\x01\x08&\"\x16\x20matrix\x20recov\
    ery\x20type\n\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xf5\x01\x08!\
    \n\x0f\n\x07\x04\x11\x04\0\x02\x01\x02\x12\x04\xf5\x01$%\n\x9e\x01\n\x02\
    \x04\x12\x12\x06\xfe\x01\0\x88\x02\x01\x1a\x8f\x01*\n\x20Response:\x20De\
    vice\x20is\x20waiting\x20for\x20user\x20to\x20enter\x20word\x20of\x20the\
    \x20mnemonic\n\x20Its\x20position\x20is\x20shown\x20only\x20on\x20device\
    's\x20internal\x20display.\n\x20@next\x20WordAck\n\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\xfe\x01\x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xff\x01\
    \x04&\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xff\x01\x04\x0c\n\r\n\x05\x04\
    \x12\x02\0\x06\x12\x04\xff\x01\r\x1c\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xff\x01\x1d!\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xff\x01$%\n1\n\x04\x04\
    \x12\x04\0\x12\x06\x83\x02\x04\x87\x02\x05\x1a!*\n\x20Type\x20of\x20Reco\
    very\x20Word\x20request\n\n\r\n\x05\x04\x12\x04\0\x01\x12\x04\x83\x02\t\
    \x18\n\x0e\n\x06\x04\x12\x04\0\x02\0\x12\x04\x84\x02\x08\"\n\x0f\n\x07\
    \x04\x12\x04\0\x02\0\x01\x12\x04\x84\x02\x08\x1d\n\x0f\n\x07\x04\x12\x04\
    \0\x02\0\x02\x12\x04\x84\x02\x20!\n\x0e\n\x06\x04\x12\x04\0\x02\x01\x12\
    \x04\x85\x02\x08$\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x01\x12\x04\x85\x02\
    \x08\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x02\x12\x04\x85\x02\"#\n\x0e\
    \n\x06\x04\x12\x04\0\x02\x02\x12\x04\x86\x02\x08$\n\x0f\n\x07\x04\x12\
    \x04\0\x02\x02\x01\x12\x04\x86\x02\x08\x1f\n\x0f\n\x07\x04\x12\x04\0\x02\
    \x02\x02\x12\x04\x86\x02\"#\nx\n\x02\x04\x13\x12\x06\x90\x02\0\x92\x02\
    \x01\x1aj*\n\x20Request:\x20Computer\x20replies\x20with\x20word\x20from\
    \x20the\x20mnemonic\n\x20@next\x20WordRequest\n\x20@next\x20Success\n\
    \x20@next\x20Failure\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x90\x02\x08\x0f\n\
    6\n\x04\x04\x13\x02\0\x12\x04\x91\x02\x04\x1d\"(\x20one\x20word\x20of\
    \x20mnemonic\x20on\x20asked\x20position\n\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\x91\x02\x04\x0c\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x91\x02\r\
    \x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x91\x02\x14\x18\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\x91\x02\x1b\x1c\nA\n\x02\x04\x14\x12\x06\x99\x02\
    \0\x9b\x02\x01\x1a3*\n\x20Request:\x20Set\x20U2F\x20counter\n\x20@start\
    \n\x20@next\x20Success\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x99\x02\x08\x15\
    \n\x17\n\x04\x04\x14\x02\0\x12\x04\x9a\x02\x04$\"\t\x20counter\n\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\x9a\x02\x04\x0c\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\x9a\x02\r\x13\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x9a\x02\
    \x14\x1f\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x9a\x02\"#\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
